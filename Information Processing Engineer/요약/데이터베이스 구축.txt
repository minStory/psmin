01 데이터베이스 구축

데이터베이스
: 특정 조직의 업무를 수행하는 데 필요한 상호 관련된 데이터들의 모임

데이터베이스 정의 ::공.장.통.운
	- 통합 데이터 : 검색의 효율성을 위해 중복의 최소화된 데이터
	- 저장 데이터 : 접근 가능한 저장 매체에 저장된 데이터
	- 운영 데이터 : 목적을 위해 존재 가치가 확실한 데이터
	- 공유 데이터 : 공동으로 사용하는 데이터

데이터 언어
	1) DDL : DB의 구조, 데이터 형식, 접근 방식 등 DB의 구축과 변경 목적으로 사용하는 언어
	2) DML : 데이터의 검색, 삽입, 삭제, 갱신 연산 등을 위한 언어
	3) DCL : 보안 및 권한 제어, 무결성, 회복, 병행 제어를 위한 언어

스키마(Schema)
: 데이터베이스의 구조와 제약조건에 관해 전반적인 명세를 기술한 것

3계층 스키마
	1) 외부 스키마(External Schema) - 사용자 뷰
		- 데이터베이스의 논리적 구조 정의
	2) 개념 스키마(Conceptual Schema) - 전체적인 뷰
		- 데이터베이스의 전체적인 논리적 구조
	3) 내부 스키마(Internal Schema) - 저장 스키마
		- 물리적 저장장치의 입장에서 본 데이터베이스 구조

데이터 독립성
	1) 논리적 독립성
		- 개념스키마가 변경되어도 외부 스키마에는 영향을 미치지 않음
	2) 물리적 독립성
		- 내부스키마가 변경되어도 외부/개념 스키마에는 영향을 미치지 않음

DBMS
: 데이터베이스를 관리하여, 공유하며 사용할 수 있는 환경 제공

DBMS의 기능
	- 데이터 정의
	- 데이터 조작
	- 데이터 제어
	- 데이터 공유
	- 데이터 보호
	- 데이터 구축
	- 유지보수

DBMS의 종류
	1) 계층형(Hierarchical DataBase) ::다대다 X
		- 데이터 간의 관계가 트리 형태의 구조
	2) 네트워크형(Network DataBase)
		- 계층형의 단점 보완, N:N(다대다) 구성 가능
		- CODASYL(코다실)이 제안
	3) 관계형(Relational DataBase)
		- 키와 값으로 이루어진 테이블 구조
	4) 객체 지향형(Object-Oriented DataBase)
		- 객체지향 프로그래밍 개념에 기반, 비정형 데이터화 가능
	5) 객체 관계형(Object-Relational DataBase)
		- 관계형 + 객체지향형, 비정형 데이터화 가능
	6) NoSQL ::(SQL을 안쓰는게 아님)
		- Not Only SQL, SQL뿐만 아니라 다양한 특성을 지원, 비정형 데이터화 가능
	7) NewSQL
		- RDBMS의 SQL + NoSQL, 비정형 데이터화 가능

데이터베이스 설계 단계
	1) 요구조건 분석
		- 사용자, 사용목적, 사용범위, 제약조건 등 내용의 명세서를 작성
	2) 개념적 설계
		- DBMS에 독립적, E-R 다이어그램
	3) 논리적 설계
		- 목표 DBMS(계층형, 관계형, 객체지향형 등)로 변환
		- 정규화 수행, 트랜잭션 인터페이스(T/I) 설계
	4) 물리적 설계
		- 특정 DBMS(Oracle, MySQL 등)로 구체화
		- 성능, 용량 설계 수행
	5) 구현
		- DDL로 기술된 명령문을 컴파일, 스키마 생성

데이터모델
: 현실세계의 요소를 인간과 컴퓨터가 이해할 수 있는 정보로 표현한 것

데이터모델 종류
	- 계층형 데이터 모델
	- 네트워크형 데이터 모델
	- 관계형 데이터 모델
	- 객체 지향형 데이터 모델

데이터모델 구분
	- 개념적 데이터 모델
	- 논리적 데이터 모델
	- 물리적 데이터 모델

데이터모델 표시해야 할 요소
	- 구조(Structure) : 데이터 구조 및 정적 성질
	- 연산(Operation) : 실제 데이터를 처리하는 방법
	- 제약조건(Constraint) : 논리적인 제약조건

개체-관계 모델
: ERD(Entity-Relationship Diagram)로 표현

	1) 개체(Entity) : 사각형
	2) 속성(Attribute)
		- 기본 : 원
		- 키 속성 : 원에 밑줄
		- 다중값 : 두개의 원
		- 유도 속성 : 원을 점선으로
	속성의 유형
		- 단일값 속성 : 값을 하나만 가질 수 있는 속성(이름, 학번 등)
		- 다중값 속성 : 값을 여러 개 가질 수 있는 속성(취미 등)
		- 단순 속성 : 더는 의미를 분해할 수 없는 속성(성별 등)
		- 복합 속성 : 의미를 분해할 수 있는 속성(주소, 생년월일 등)
		- 유도 속성 : 다른 속성의 값에서 유도되어 결정되는 속성(주민번호와 성별)
		- 널 속성 : 결정되지 않은 존재하지 않는 값
		- 키 속성 : 개체를 식별하는 데 사용하는 속성
	3) 관계(Relationship) : 마름모

데이터모델 품질 기준 ::정.완.이가 준. 강아지가 최(제).일. 활.발해
	- 정확성
	- 완전성
	- 준거성
	- 최신성
	- 일관성
	- 활용성

논리적 데이터 모델링
: 개념적 설계에서 추출된 속성들의 관계를 구조적으로 설계하는 단계 -> 관계 모델

정규화(Normalization)
: 관계형 데이터베이스의 설계에서 중복을 최소화하게 데이터를 구조화

이상 현상(Anomaly) ::삽살(삭)개(갱)
: 데이터 중복으로 인해 데이터 조작 시 예상하지 못한 현상이 발생
	1) 삽입 이상 : 불필요한 데이터가 함께 삽입되는 현상
	2) 삭제 이상 : 튜플을 삭제할 때 연쇄삭제로 인해 정보 손실
	3) 갱신 이상 : 속성값을 갱신할 때 일부만 갱신되어 정보에 모순이 생기는 현상

함수적 종속(Functional Dependency)
: X의 값을 알면 Y의 값을 알 수 있을 때, Y는 X의 함수적 종속이라고 한다. (X -> Y)

함수적 종속 관계
	- 완전 함수적 종속 : 기본키를 구성하는 모든 속성이 포함된 키본키의 부분집합에 종속된 경우
	- 부분 함수적 종속 : 기본키가 여러 속성으로 구성될 때, 그중 일부만 종속되는 경우
	- 이행적 함수 종속 : X -> Y, Y -> Z, 일때 X -> Z 가 성립하는 경우

정규화 과정 ::도부이걸다조
	1) 비정규 릴레이션
		↓도메인이 원자값
	2) 	1NF
		↓부분 함수적 종속 제거
	3)	2NF
		↓이행적 함수 종속 제거
	4)	3NF
		↓결정자이면서 후보키가 아닌 것 제거
	5)	BCNF
		↓다치 종속 제거
	6)	4NF
		↓조인 종속성 이용
	7)	5NF

물리 데이터베이스 설계 과정
	- 사용자 DBMS 결정 -> 특정 DBMS
	- 데이터 타입 크기 결정
	- 데이터 용량, 설계 및 업무 프로세스 분석
	- 역정규화(반정규화)
	- 인덱스 정의
	- 데이터베이스 생성

반정규화
: 시스템의 성능향상을 위해 정규화에 위배되는 중복을 허용하는 기법

반정규화 시 고려사항
	- 중복이 발생하여 무결성이 깨질 수 있다
	- 읽기 속도 향상, 삽입/삭제/갱신 속도 저하
	- 저장 공간 효율성 떨어짐
	- 테이블이 크고 복잡해져 유지보수 어려움
	- 과도한 반정규화는 성능을 저하시킴

반정규화 적용 순서
	1) 반정규화 대상 조사 : 일정 범위만 조회, 대량의 데이터, 많은 조인 등의 상황
	2) 다른 방법으로 유도 : 뷰, 인덱스, 클러스터링, 파티셔닝, 로직 변경
	3) 반정규화 수행 : 반정규화 수행

데이터베이스 이중화
: 장애발생을 대비하여 데이터베이스를 중복시켜 동시에 갱신하여 관리하는 방법

이중화의 분류
	- Eager 기법 : 트랜잭션 도중에 변경 즉시 모든 이중화서버로 전달하여 내용 변경
	- Lazy 기법 : 트랜잭션이 완전히 완료된 후에 변경 사실을 각 노드에게 전달하여 변경

이중화의 종류
	1) Active-Active : 두 대 모두 가동되는 방식
	2) Active-Standby : 두 대 중 하나는 가동이 되고, 하나는 준비 상태로 대기
		- Hot Standby : 즉시 사용 가능
		- Warm Standby : 설정에 대한 준비 필요
		- Cold Standby : 장비를 정지시켜둠

데이터베이스 백업
: 시스템 중단 사태에 대비하여 복구를 진행할 수 있도록 데이터를 주기적으로 복사하는 것

백업 방식
	1) 전체 백업(Full Backup)
		- Data를 모두 백업
	2) 증분 백업(Incremental Backup)
		- Full 백업 이후 변경/추가된 Data만 백업
	3) 차등 백업(Differential Backup)
		- Full 백업 이후 변경/추가된 Data를 모두 포함하여 백업
	4) 실시간 백업(RealTime Backup)
		- 즉각적으로 변경사항을 복사하여 백업
	5) 트랜잭션 로그 백업(Transaction Log Backup)
		- REDO, UNDO로 복원
	6) 합성 백업
		- 전체 백업본과 여러 개의 증분 백업을 합하여 새로운 전체 백업을 만드는 작업

복구 시간 목표/복구 시점 목표
	1) 복구 시간 목표(RTO)
		- 서비스 중단-복구 시점 간에 허용되는 최대 지연 시간
	2) 복구 시점 목표(RPO)
		- 서비스 중단-복구 시점 간에 허용되는 데이터 손실량

데이터베이스 암호화
: 데이터베이스의 내용을 암호화하는 것

암호화 방식
	- API 방식 : 애플리케이션에서 데이터의 암/복호화 -> 프로그램 단에서 암호화
	- Plug-in 방식 : 서버에 제품을 설치하여 암/복호화 -> 제품을 구매해서 끼워 넣어 암호화
	- TDE 방식 : DBMS에 내장 또는 옵션으로 제공되는 암호화 -> 기본 제공 암호화 방식
	(Transparent Data Encryption)

파티셔닝
: 데이터베이스를 여러 부분으로 분할하는 것

샤딩(Sharding)
: 하나의 데이터베이스를 여러 개의 작은 조각으로 나누어 분산 저장하여 관리하는 것

파티셔닝의 종류
	1) 수평 분할(Horizontal Partitioning) : 행(튜플)을 기준으로 분할
	2) 수직 분할(Vertical Partitioning) : 열(속성)을 기준으로 분할

분할 기준
	1) 범위 분할(Range Partitioning) : 범위로 파티션을 정의 (월별, 분기별 등)
	2) 목록 분할(List Partitioning) : 특정 파티션에 저장될 Data에 대한 명시적 제어
				(한국, 일본, 중국 -> 아시아) (노르웨이, 스웨덴 -> 북유럽)
	3) 해시 분할(Hash Partitioning) : 키값에 해시 함수 적용, 반환된 값으로 파티션 매핑
	4) 라운드 로빈 분할 (Round Robin Partitioning) : 데이터를 균일하게 분배해서 저장
	5) 합성 분할(Composite Partitioning) : 위의 기술들을 복합적으로 사용

클러스터
: 디스크로부터 데이터를 읽어오는 시간을 줄이기 위해서 자주 사용되는 데이터를
  같은 위치에 저장시키는 방법

클러스터 대상 테이블
	- 분포도가 넓은 테이블
	- 대량의 범위를 자주 조회하는 테이블
	- 입력, 수정, 삭제가 자주 발생하지 않는 테이블
	- 자주 JOIN되어 사용되는 테이블
	- ORDER BY, GROUP BY, UNION이 빈번한 테이블

인덱스
: 추가 저장공간을 활용하여 테이블의 검색 속도를 향상시키기 위한 자료구조

인덱스의 종류
	1) 클러스터 인덱스
		- 테이블당 1개만 허용, 원본이 정렬
	2) 넌클러스터 인덱스
		- 테이블당 약 240개의 인덱스 생성 가능
		- 원본은 정렬되지 않고, 인덱스 페이지만 정렬
	3) 밀집 인덱스
		- 레코드 각각에 대해 하나의 인덱스가 만들어짐 -> 레코드마다(각각)
	4) 희소 인덱스
		- 그룹 또는 데이터 블록에 대해 하나의 인덱스가 만들어짐 -> 그룹마다(띄엄띄엄)

뷰
: 기본 테이블로부터 유도된 가상 테이블

뷰의 장/단점
	장점	- 논리적 독립성을 제공 -> 외부스키마에 해당
		- 여러 사용자의 상이한 요구를 지원
		- 사용자의 데이터관리를 간단하게 해줌
		- 접근 제어를 통한 자동 보안 제공

	단점	- 독립적인 인덱스를 가질 수 없음
		- ALTER VIEW문을 사용할 수 없음
		- 삽입, 삭제, 갱신에 제약이 따름

시스템 카탈로그 ::컴퓨터가 자동으로 생성
: 모든 데이터 개체들에 대한 정의나 명세에 대한 정보가 수록되어 있는 시스템 테이블
  (데이터 사전이라고도 함)

시스템 카탈로그의 특징
	- 사용자가 SQL문을 이용하여 내용을 검색해 볼 수 있다
	- 시스템에 의해 생성되고 유지된다
	- 사용자의 접근은 가능하고, 수정은 불가능하다.

관계 데이터 모델
: 데이터가 릴레이션, 테이블 형태의 평면 파일로 표현되는 데이터 모델
	구조		설명
	속성(Attribute)	- 릴레이션의 각 열
			- 데이터를 구성하는 가장 작은 단위
			- 속성의 수 = 디그리(Degree) = 차수
	튜플(Tuple)	- 릴레이션의 각 행
			- 튜플의 수 = 카디널리티(Cardinality) = 기수
	도메인(Domain)	- 하나의 속성이 가질 수 있는 값의 범위
	차수(Degree)	- 속성의 전체 개수
	기수(Cardinality)	- 튜플의 전체 개수

릴레이션
: 데이터들을 2차원 테이블의 구조로 저장한 것
	1) 릴레이션의 구성
		- 릴레이션 스키마 : 릴레이션의 논리적 구조
		- 릴레이션 인스턴스 : 스키마에 저장된 데이터의 집합
	2) 릴레이션의 특징
		- 튜플의 유일성
		- 튜플의 무순서성
		- 속성의 무순서성
		- 속성의 원자성
		- 삽입, 갱신 삭제가 실시간으로 일어나므로 릴레이션은 수시로 변한다

관계대수 ::네비게이션
: 데이터를 얻기 위한 처리 과정을 명시하는 절차적인 언어

순수 관계 연산자
	1) SELECT
		- 주어진 조건을 만족하는 튜플을 선택하는 연산자
		- 시그마
		- AND, OR, NOT 사용 가능
	2) PROJECT
		- 제시된 속성 값만을 추출하는 연산자
		- 파이
	3) JOIN
		- 두 개의 릴레이션으로부터 연관된 튜플들을 결합하는 연산자
		- 보타이
	4) DIVISION
		- 릴레이션 S의 모든 튜플과 관련이 있는 릴레이션 R의 튜플들을 반환

일반 집합 연산자
	1) 합집합(Union)
		- 합집합을 구하되, 중복되는 튜플은 제거
	2) 교집합(Intersection)
		- 교집합을 구하는 연산
	3) 차집합(Difference)
		- 튜플의 차집합을 구하는 연산
	4) 교차곱(Cartesian Product)
		- 두 릴레이션에 있는 튜플들의 순서쌍을 구하는 연산

관계 해석
: 원하는 정보가 무엇이라는 것만 정의하는 비절차적 특성
	구분	종류
	연산자	OR
		AND
		NOT
	정량자	A 거꾸로, For All
		E 거꾸로, 어떤 튜플 하나라도 존재

속성
: 각 열의 상태나 특성을 나타내는 항목

속성의 분류
	- 기본속성
	- 설계속성
	- 파생속성

세부 의미에 따른 분류
	- 단순 속성 : 나이, 성별같이 다른 속성들로 구성될 수 없는 단순한 속성
	- 복합 속성 : 주소와 같이 시, 구, 동 처럼 여러 세부 속성들로 구성될 수 있는 속성

구성 방식에 따른 분류
	- PK(Primary Key) 속성 : 튜플을 유일하게 구분할 수 있는 속성
	- FK(Foriegn Key) 속성 : 다른 릴레이션과의 관계에서 참조하고 있는 속성
	- 일반 속성 : PK와 FK가 아닌 속성

도메인
: 속성이 가질 수 있는 값의 범위

키(Key) ::나를 구분할 수 있는 속성
: 다른 튜플들과 구별할 수 있는 유일한 기준

키의 종류
	1) 후보키(Candidate Key)
		- 튜플을 유일하게 식별할 수 있는 속성들의 부분집합
		- 유일성 + 최소성 만족
	2) 기본키(Primary Key) ::후보키 중 가장 적합한 키
		- 후보키 중에서 선택한 주키(Main Key)
		- 특정 튜플을 유일하게 구별할 수 있는 속성
	3) 대체키(Alternate Key)
		- 기본키를 제외한 나머지 후보키
	4) 슈퍼키(Super Key)
		- 속성들로 구성된 모든 조합
		- 유일성 O, 최소성 X
	5) 외래키(Foriegn Key)
		- R1이 참조하고 있는 R2의 기본키와 같은 R1 릴레이션 속성

데이터베이스 무결성
: 데이터의 정확성, 일관성, 유효성이 유지되는 것

무결성의 종류
	1) 개체 무결성(Entity Integrity) ::주민번호
		- 기본키는 중복되지 않은 고유한 값을 가져야 한다
		- 기본키는 NULL 값을 허용하지 않는다.
	2) 참조 무결성(Referential Integrity) ::쇼핑몰의 상품
		- 외래키 값은 NULL 이거나 참조하는 릴레이션의 기본키 값과 동일해야 한다
		- 외래키는 참조테이블에 없는 값을 가질 수 없다.
			제약조건		설명
			제한(Restrict)	문제가 되는 연산을 거절 (참조 시 삭제 거절)
			연쇄(Cascade)	부모를 삭제하면 참조하고 있는 자식도 삭제
	3) 도메인 무결성(Domain Integrity) ::성별(남, 여), 학년(1~4)
		- 속성들의 값은 정의된 도메인에 속한 값이어야 한다.
		- 성별이라는 컬럼에는 남, 여를 제외한 데이터는 제한되어야 한다.
	4) 고유 무결성(Unique Integrity)
		- 속성 값들이 서로 달라야 한다.
	5) 키 무결성(Key Integrity)
		- 적어도 하나의 키가 존재해야 한다.
	6) 릴레이션 무결성(Relation Integrity)
		- 삽입, 삭제, 갱신과 같은 연산을 수행하기 전과 후에 대한 상태의 제약

CRUD ::CRUD Matrix 표현 가능
: Create, Read, Update, Delete를 묶어서 표현한 것

옵티마이저
: SQL문에 대해 최적의 실행 방법, 계획 결정

SQL 처리 흐름
	- SQL -> 구문분석(Parsing) -> 실행(Execution) -> 인출(Fetch) -> 결과
		        ↑참조		↑참조	        ↑참조
			Database 통계자료		Database Data

	1) 구문분석 단계
		- 요청한 SQL문이 데이터베이스에서 사용된 적이 있는지 확인
	2) 실행 단계
		- 사용된 데이터가 버퍼캐시 영역에 존재하는지 검색
	3) 인출/추출 단계
		- 데이터를 읽어서 요청한 클라이언트로 전송
		- SELECT문에 해당

옵티마이저의 구분
	- 규칙기반 옵티마이저 : 우선순위를 가지고 실행 계획 생성
	- 비용기반 옵티마이저 : 통계정보를 활용하여 비용이 가장 적은 실행 계획 생성

튜닝 ::S/W에서 '클린코드'와 동일
: SQL문을 최적화하여 빠른 시간 내에 원하는 결과값을 얻기 위한 작업,
  처리량과 응답속도 개선
	1) Row Migration : 데이터가 커져서 기존 블록에 못 들어가는 경우
			기존 블록 위치에 링크를 남긴다
	2) Row Chaining : 컬럼이 블록보다 길어진 경우 블록 두 개를 이어서 한 Row가 저장

분산 데이터베이스 ::투명성
: 분산되어있는 데이터베이스를 하나의 가상 시스템으로 사용할 수 있도록 한 데이터베이스

구성요소
	- 분산 처리기
	- 분산 데이터베이스
	- 통신 네트워크

적용 기법
	1) 테이블 위치 분산 : 테이블의 위치를 각각 다르게 위치시키는 것
	2) 테이블 분할 분산 : 테이블을 쪼개어 분산시키는 것
		- 수평분할
		- 수직분할
	3) 테이블 복제 분산 : 테이블을 복제하여 동시에 관리하는 것
		- 부분 복제 : 일부의 내용만 복제
		- 광역 복제 : 마스터 데이터베이스(전체 내용) 복제
	4) 테이블 요약 분산 : 지역 간, 서버 간에 데이터가 서로 다른 유형으로 존재
		- 분석 요약 : 지사에서 정보를 통합하여 분산
		- 통합 요약 : 본사에서 정보를 통합하여 분산

투명성 조건 ::병.장.위.중.분.지
	- 위치 투명성(Location) : 데이터가 물리적으로 저장된 곳을 알 필요 없다.
	- 분할 투명성(Division) : 하나의 테이블의 사본이 여러 위치에 저장
	- 지역사상 투명성(Local Mapping) : 지역DBMS와 물리적 DB 사이의 Mapping 보장
	- 중복 투명성(Replication) : 데이터가 여러 곳에 중복되어 있더라도 하나의 것처럼 사용
	- 병행 투명성(Concurrency) : 다수의 트랜잭션이 동시 실현 되어도 결과는 영향이 없음
	- 장애 투명성(Failure) : 시스템 장애가 발생하여도 트랜잭션을 정확하게 처리

CAP 이론
: 일관성, 가용성, 분단 허용성 세가지 속성 중, 두 가지만 가질 수 있다
	1) 일관성(Consistency)
	2) 가용성(Availability)
	3) 분단 허용성(Partition Tolerance)

트랜잭션 ::A.C.I.D -> 은행업무
: 상태를 변환시키는 하나의 논리적인 작업 단위

트랜잭션의 성질
	- 원자성(Atomicity) : 모두 반영되든지 전혀 반영되지 않아야 한다(Commit, Rollback)
	- 일관성(Consistency) : 언제나 일관성 있는 데이터베이스 상태로 변환
	- 독립성(Isolation) : 하나의 트랜잭션 실행 중에 다른 트잭잭션의 연산이 끼어들 수 없다
	- 영속성(Durability) : 시스템이 고장이 나더라도 영구적으로 반영되어야 한다.

트랜잭션의 상태
			활동(Active)
			↙↘
		실패(Failed)	부분완료(Partial Committed)
		↙		     ↘
	철회(Absorb)			완료(Committed)
	- 활동(Active) : 트랜잭션이 실행 중인 상태
	- 실패(Failed) : 오류가 발생하여 중단된 상태
	- 철회(Absorb) : 비정상적으로 종료되어 Rollback 연산을 수행한 상태
	- 부분완료(Partially Committed) : 마지막 연산까지 실행했지만, Commit 연산 직전의 상태
	- 완료(Committed) : 성공적으로 종료되어 Commit 연산을 실행한 후의 상태

02 SQL 활용

SQL(Structured Query Language)
: 데이터베이스 시스템에서 자료를 처리하는 용도로 사용되는 구조적 데이터 질의 언어

SQL 문법의 종류
	1) DDL : 데이터가 저장되는 테이블이나 각종 개체들을 정의하는 데 사용되는 명령
		CREATE, ALTER, DROP, RENAME, TRUCATE
	2) DML : 데이터베이스 내의 데이터를 조작하는 명력
		INSERT, DELETE, UPDATE, SELECT
	3) DCL : 데이터베이스에 접근하고, 객체들을 사용하도록 권한을 주고 회수하는 명령
		GRANT, REBOKE
	4) TCL : 작업의 단위를 묶어 조작된 결과를 작업 단위별로 제어하는 명령어
		COMMIT, ROLLBACK, SAVEPOINT

저장 프로시저(Stored Procecure) ::함수, 리턴값이 있을 수도 있고 없을 수도 있다
: 일련의 쿼리를 하나의 함수처럼 실행하기 위한 쿼리의 집합
	CREATE OR REPLACE PROCEDURE ~
	(변수, IN, OUT, IN OUT)
	IS
	BEGIN
	EXCEPTION
	END;

트리거 ::방아쇠를 당기다 -> 죽다
: 이벤트에 반응해 자동으로 실행되는 작업

트리거의 유형
	1) 행트리거 : FOR EACH ROW
	2) 문장 트리거 : 단 한 번만 실행

사용자 정의 함수 ::무조건 리턴값이 있어야 한다.
: 호출하게 되면 미리 정의해 놓은 기능을 수행하는 모듈
	CREATE OR REPLACE FUNCTION ~
	(매개변수1,2,3..)
	RETURN ~
	IS
	BEGIN
	EXCEPTION
	END;

03 병행제어와 데이터전환

병행제어
: 여러 트랜잭션들이 동시에 실행되면서도 일관성을 유지할 수 있게 하는 기법

병행제어의 문제점
	1) 갱신분실(Lost Update)
		- 갱신할 때 결과의 일부가 없어지는 현상
	2) 비완료 의존성(Uncommitted Dependency)
		- 트랜잭션 수행이 실패한 후 회복되기 전에 다른 트랜잭션이
		  실패한 갱신 결과를 참조하는 현상
	3) 모순성(Inconsistency)
		- 여러 데이터를 가져올 때 발생하는 문제
	4) 연쇄 복귀(Cascading Rollback)
		- 병행수행된 트랜잭션 중 하나에 문제가 생겨 Rollback되는 경우
		  다른 트랜잭션도 함께 Rollback되는 현상

병행제어 기법
	1) 로킹(Locking) ::화장실 자물쇠
		- 트랜잭션이 어떤 데이터에 접근하고자 할 때 로킹 수행
			로킹단위		로크수		병행성		오버헤드
			    ↑		    ↓		   ↓		     ↓
			    ↓		    ↑		   ↑		     ↑

	2) 2단계 로킹 규약
		- 일관성 보장을 위해 Lock단계과, Unlock단계를 구분
		- 확장 단계 : Lock은 가능하고 Unlock은 불가능하다
		- 축소 단계 : Unlock은 가능하고 lock은 불가능하다
	3) 타임스탬프
		- 시간의 순서대로 데이터에 접근하여 수행
	4) 낙관적 병행제어
		- 트랜잭션 종료 시에 일괄적으로 검사
	5) 다중 버전 병행제어
		- 여러 버전의 타임스탬프를 비교하여 선택

회복(Recovery)
: 손상된 데이터베이스를 손상되기 이전의 정상적인 상태로 복구시키는 작업

Undo와 Redo
	- Undo : 오류와 관련된 모든 변경을 취소하여 복구 수행
	- Redo : 오류가 발생한 트랜잭션을 재실행하여 복구 수행

회복 기법
	1) 로그 기반 회복 기법
		ㄱ. 지연갱신 회복 기법
			- 커밋이 발생하기 전까지 데이터베이스에 기록하지 않음
			- Redo만 실행
		ㄴ. 즉시갱신 회복 기법
			- 변경 내용을 즉시 데이터베이스에 기록
			- Undo + Redo 실행
	2) 검사점 회복 기법
		- 검사점 이후에 처리된 트랜잭션만 회복 작업 수행
	3) 그림자 페이징 회복 기법 ::복사본으로 회복
		- 메모리상의 Table과 하드디스크의 Table 이용
	4) 미디어 회복 기법
		- 디스크와 같은 비휘발성 저장 장치가 손상되는 장애 발생을 대비한 회복 기법
	5) ARIES 회복 기법 ::알고리즘 이용
		- 분석 단계
		- REDO 단계
		- UNDO 단계

ETL(Extraction, Transformation, Loading) ::이관(Migration)
: 데이터를 추출, 변환, 적재하는 일련의 과정

ETL 기능
	- 추출 : 데이터 획득
	- 변환 : 데이터 형식 변환 및 통합
	- 적재 : 목표 시스템에 적재























