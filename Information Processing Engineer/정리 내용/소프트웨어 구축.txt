01 소프트웨어 공학

소프트웨어 공학
: 품질 높은 소프트웨어를 개발하기 위한 학문

소프트웨어 공학 3R
	1) 역공학(Reverse Engineering)
	   : 개발 단계를 역으로 올라가 기존 개발된 시스템의 코드나 데이터로부터 명세서를 도출하는 작업
	2) 재공학(Re-Engineering)
	   : 유지보수의 생산성으로 소프트웨어의 위기를 해결하려는 방법
		- 예방 유지보수 측면
		- 분석 -> 재구성 -> 역공학 -> 이관
	3) 재사용(Reuse)
	   : 이미 개발되어 있는 소프트웨어를 다시 사용
		- 합성 중심 : 블록(모듈)을 만들어서 끼워 맞추워 완성시키는 방법
		- 생성 중심 : 추상화 형태로 명세를 구체화 하여 프로그램을 만드는 방법

소프트웨어 개발 단계
	계획 -> 요구사항 분석 -> 설계 -> 구현 -> 테스트 -> 유지보수

소프트웨어 개발 방법론
: 소프트웨어 개발에 필요한 과정들을 체계적으로 정리한 것

소프트웨어 개발 방법론 종류
	1) 구조적 방법론
		- 절차지향 개발 방법론
		- 구성요소 : 데이터 흐름도(DFD), 자료 사전(DD), 상태전이도(STD), 소단위 명세서(Minispec)
	2) 정보공학 방법론 ::기업
		- 기업에 정형화된 기법들을 통합, 적용하는 개발 방법론
	3) 객체지향 방법론
		- 개체(Entity)를 속성(Attribute)과 메서드(Method)형태로 표현
		- 특징 : 캡슐화, 정보은닉, 상속, 다형성, 추상화

소프트웨어 개발 모델
	1) 폭포수 모델(Watefall Medel)
		- 계획, 분석, 설계, 구현, 테스트, 운영 등 전 과정을 순차적으로 접근하는 개발모델
		- 가장 오래된 모델
	2) 프로토타이핑 모델(Prototyping Model) ::시제품
		- 고객이 요구한 주요기능을 프로토타입으로 구현하는 모델
	3) 나선형 모델(Spiral Model) ::위험분석
		- 위험 분석을 추가한 점증적 개발 모델
		- 프로젝트 수행 시 위험 관리 최소화가 목적
		- 대규모 프로젝트에 적합
		- 계획 및 요구분석 -> 위험분석 -> 개발 -> 사용자 평가 -> 계획 및 요구분석 (반복)
	4) RAD(Rapid Application Development) 모델
		- 매우 짧은 개발 주기를 강조
		- CASE 도구 이용
	5) V 모형
		- 폭포수 모델에 시스템 검증과 테스트 작업 강조
		- 단위테스트 -> 통합테스트 -> 시스템테스트 -> 인수테스트
	6) 4세대 기법
		- 명세서로부터 코드를 자동으로 생성할 수 있게 해주는 모델

애자일(Agile) 방법론 ::고객 중시
: 신속한 반복 작업을 통해 실제 작동 가능한 소프트웨어를 개발하여 지속적으로 제공하기 위한 소프트웨어 개발 방식

애자일 방법론 종류
	1) XP(eXtream Programmin)	-> '의사'선생님 약 주실 때 '피''존' '용기'에 '단'아주세요
		- 용기, 존중, 의사소통, 피드백, 단순성
	2) 스크럼(Scrum)
		- 30일 정도의 주기로 실제 동작할 수 있는 결과를 제공
		- 매일 15분 정도의 회의
	3) 크리스털(Crystal)
		- 프로젝트의 규모에 따라서 여러 종류의 방법론 제공
	4) FDD(Feature-Driven Development)
		- 특징(신규 기능)마다 2주 정도의 반복 개발 실시
	5) ASD(Adaptive Software Development)
		- 혼란 자체로 규정하고, 그에 적응할 수 있는 방법론 제시
	6) 린(Lean)
		- 도요타 린 시스템 품질기법 적용

IT 서비스 관리
	1) SLM(Service Level Management)
		- 품질을 높이는 일련의 관리 및 활동
	2) SLA(Service Level Agreement)
		- 서비스 수준을 명시적으로 정의한 문서
	3) ITSM(Information Technology Service Management)
		- 최종 사용자를 위한 IT 서비스를 구현, 전달, 관리하기 위한 일련의 정책과 관행
	4) ITIL(IT Infrastructure Library)
		- ITSM을 실현하는 도구

02 프로젝트 계획 및 분석

프로젝트 관리
: 특정한 목적을 가진 프로젝트를 한정된 기간, 예산, 자원 내에서 사용자가 만족할 만한 제품을 개발하도록
  행하는 기술적, 관리적 활동

프로젝트 핵심 관리대상(3P)
	1) 사람(People)
		- 프로젝트 관리에서 가장 기본이 되는 요소
	2) 문제(Problem)
		- 처리해야 할 내용 분석, 설계
	3) 프로세스(Process)
		- 개발에 필요한 골격 제공

PMBOK(Project Management Body of Knowledge)
	- PMI(Project Management Institute)에서 제작한 프로젝트 관리 프로세스
	- PMBOK 5단계 : 프로젝트 착수 -> 계획 -> 실행 -> 통제 -> 종료

개발 비용 산정
	1) 하향식 산정 기법
		- 전문가 기법 : 경험이 있는 전문가에게 비용 산정을 의뢰
		- 델파이 기법 : 여러 전문가의 의견을 종합하여 판단하는 기법
	2) 상향식 산정 기법
		- LOC(원시코드 라인 수) 기법 : 비관치, 낙관치, 중간치(기대치)
		- 단계별 인원수(M/M) 기법 : 생명주기 단계별로 모든 단계의 비용을 산정
	3) 수학적 산정 기법
		- COCOMO 기법
			조직형			5만 라인 이하의 프로젝트
			(Organic Mode)
			반분리형			30만 라인 이하의 프로젝트
			(Semidetached Mode)
			내장형			30만 라인 이상의 프로젝트
			(Embedded Mode)
		- Putnam 기법 : Rayleigh-Norden 곡선, SLIM
		- 기능 점수 기법(FP, Function Point) : ESTIMACS
			데이터	내부논리파일
				외부연계파일
			트랜잭션	외부입력
				외부출력
				외부조회

개발 일정 산정
: 어떤 작업이 필요한지 정의하고, 작업들의 우선순위를 정하여 프로젝트 일정에 대한 계획을 세우는 것

작업 분해(Work Breakdown Structure) -> CPM(P/C) 네트워크 작성 -> 최소 소요기간(임계경로) 구함 ->
CPM 수정 -> 간트 차트로 표현

	1) WBS(Work Breakdown Structure) : 필요한 활동과 업무를 세분화하는 작업
	2) Network Chart(PERT/CPM)
		- PERT : 전체 프로젝트의 시간단축을 목표로 일정계획 및 진행과정을 효율적으로 관리
		- CPM : 전체 프로젝트의 시간단축을 목표로 최소의 비용 추가 투입 고려
		- PERT/CPM : PERT + CPM, 임계경로, 빠른 착수일, 늦은 착수일, 여유기간
	3) 간트차트(Gantt Chart) : 일정 관리를 위한 바(bar) 형태의 도구

현행 시스템 분석

플랫폼 정의
: 애플리케이션을 구동시키는 데 필요한 하드웨어와 소프트웨어의 결합

	기능	 	설명
	연결기능		연결을 가능하게 하는 장소 제공하여 교류를 촉진
	비용감소		플랫폼을 제공하여 각 그룹이 처리할 때 발생하는 비용 절감
	브랜드 신뢰 기능	플랫폼의 브랜드가 사용자에게 신뢰감을 부여
	커뮤니티 형성	그룹 간 상호 작용을 통한 커뮤니티 형성

	종류		설명
	하드웨어 플랫폼	실제 생활의 다양한 부분에서 접하는 물리적 구조물
	소프트웨어 플랫폼	다양한 애플리케이션이 작동하는 기반이 되는 운영체제
	서비스 플랫폼	다른 서비스들이 나의 서비스를 쉽게 사용할 수 있게 해주는 인터넷 기반의 기술 환경

	유형			설명
	싱글 사이드 플랫폼	소비자와 공급자를 연결하는 형태
	투 사이드 플랫폼		두 그룹을 중개
	멀티 사이드 플랫폼	다양한 이해관계 그룹을 연결하는 형태

CPND : Content, Platform, Network, Device ::유튜브

미들웨어
: 양 쪽을 연결하여 데이터를 주고 받을 수 있도록 중간에서 매개 역할을 하는 소프트웨어

미들웨어 종류
	1) 원격 프로시저 호출(RPC, Remote Procedure Call)
		- 클라이언트가 원격 프로시저 호출
	2) 메시지 지향 미들웨어(MOM, Message Oriented Middleware)
		- 메시지를 전달하는 방식의 비동기식 미들웨어
	3) ORB(Object Request Broker)
		- 객체지향 시스템에서 지원하는 미들웨어
	4) DB 접속 미들웨어
		- App과 DB서버를 연결해주는 미들웨어
	5) TP 모니터
		- 분산시스템(트랜잭션) 감시 및 제어
	6) 웹 애플리케이션 서버(WAS, Web Application Server)
		- 동적인 콘텐츠를 처리하기 위한 미들웨어
	7) 엔터프라이즈 서비스 버스(ESB, Enterprise Service Bus)
		- 메시지 기반으로 느슨한 결합 형태의 표준 인터페이스 통신을 지원하는 미들웨어

요구 공학
: 고객의 요구사항을 도출하고 관리하는 기법

요구사항 내용의 종류
	1) 기능적 요구사항 : 소프트웨어를 구성하는 기능들을 정의한 것
	2) 비기능적 요구사항 : 기능들에 대한 조건과 제약 사항들을 정의한 것 (보안, 품질, 성능, 안정성 등)

요구사항 개발 프로세스
	도출 -> 분석 -> 명세 -> 확인

	1) 도출 : 요구사항이 어디에 있고, 어떻게 수집할 것인가를 확인
	2) 분석
		- DFD(Data Flow Diagram) : 자료 흐름도
		- Data Dictionary : 자료 사전
		- Mini-Spec : 소단위 명세서
		- ERD(Entity Relationship Diagram) : 개체 관계도
		- STD(State Transition Diagram) : 상태 전이도
	3) 명세 : 정형 명세 기법, 비정형 명세 기법
	4) 확인 : 이해 관계자들이 문서를 검토하고, 형상관리를 수행

요구사항 분석 도구

	분류		설명
	상위 CASE	생명주기 전반부에 사용(계획, 분석, 설계 단계)
	하위 CASE	생명주기 후반부에 사용(테스트, 문서화)
	통합 CASE	생명주기 전체 과정을 지원

	- HIPO : 하향식 소프트웨어 개발을 위한 문서화 도구

		종류		설명
		가시적 도표	시스템의 전체 기능과 흐름을 보여주는 계층 구조
				입력,처리 출력 없음
		총체적 도표	기능을 기술
				입력, 처리, 출력에 대한 전박적인 정보 제공
		세부적 도표	총체적 도표보다 좀 더 상세히 기술하는 도표

요구사항 분석 모델링

모델링 : 복잡한 시스템을 간단한 모델로 표현하는 것을 의미 ::그림

모델링 구분

	구분		설명
	기능적 모델링	기능을 사용자 관점으로 표현
	정적 모델링	구조를 파악하여 클래스 단위로 표현
	동적 모델링	어떤 기능을 수행하는지의 상호작용 표현

구조적 분석 모델

구조적 분석 방법론 : 절차에 따라 사용자 요구사항을 파악하고 문서화하는 분석 기법(하향식 기능 분해 기법)

구조적 분석 도구
	1) 자료 흐름도(DFD) : 처리 과정, 자료 흐름, 자료 저장소, 단말
	2) 자료 사전(DD)
		기호	의미	설명
		=	정의	~로 구성되어 있다
		+	연결	그리고, AND
		( )	생략	생략 가능한 자료
		[ | ] 	선택	여러 대안 중 하나 선택
		{ }	반복	자료의 반복
		* *	설명	주석
	3) 소단위 명세서 : 각 처리들이 수행하는 업무를 상세하게 작성
	4) 개체 관계도(ERD) : 개체, 속성, 관계를 표현하여 모델화
	5) 상태 전이도(STD) :: ex) 프로세스 (준비, 실행, 대기) 과정

객체지향 분석 모델

객체지향 분석 방법론
	1) Rumbaugh(럼바우) 방법 ::격(객)동기
		종류		설명
		객체 모델링	객체 다이어그램으로 표현
		동적 모델링	상태 다이어그램으로 표현
		기능 모델링	자료 흐름도(DFD)으로 표현
	2) Booch(부치) 방법
		- 미시적, 거시적 개발 프로세스
	3) Jacobson 방법
		- Use case 강조
	4) Coad와 Yourdon 방법
		- E-R 다이어그램
	5) Wirfs-Brock 방법
		- 분석과 설계 간 구분 없음

03 소프트웨어 설계

소프트웨어 설계
: 요구사항 명세서를 참조하여 물리적으로 구현 가능하도록 구체적인 설계서를 작성하는 단계

소프트웨어 설계의 원리
	1) 분할과 정복(Divide & Conquer) : 규모가 큰 소프트웨어를 여러 개의 작은 서브시스템으로 나눈다
	2) 추상화(Abstraction) : 과정 추상화, 데이터 추상화, 제어 추상화
	3) 단계적 분해(Stepwise Refinement) : 기능을 점점 작은 단위로 나누어 점차적으로 구체화
	4) 모듈화(Modulization) : 실제로 개발할 수 있는 작은 단위로 나눈다
	5) 정보은닉(Information Hiding) : 다른 객체에게 자신의 정보를 숨긴다

설계 모델링
: 소프트웨어를 구성하는 모듈들의 연결을 그림으로 표현한 것

설계 모델링 유형
	1) 구조 모델링 : UML 정적 다이어그램
	2) 행위 모델링 : UML 동적 다이어그램

소프트웨어 설계 절차 및 유형
	- 아키텍쳐 설계
	- 데이터베이스 설계
	- 서브시스템 설계
	- 컴포넌트 설계
	- 자료구조와 알고리즘 설계
	- 협약에 의한 설계 (선행 조건, 결과 조건, 불변 조건)

소프트웨어 아키텍처(Software Architecture)
: 소프트웨어의 골격이 되는 기본구조

소프트웨어 아키텍처의 특징
	- 간략성
	- 추상화
	- 가시성
	- 관점 모형
	- 의사소통수단

소프트웨어 아키텍처 4+1 뷰

	논리적 관점			구현 관점
	(기능적 요구사항)			(개발환경, 모듈의 구성)
			유스케이스 관점
			(다른 뷰를 검증하는데 사용)
	프로세스 관점			배치 관점
	(프로그램 실행 시의 시스템 표현)	(물리적인 노드에 어떻게 배치되는가)

소프트웨어 아키텍처 패턴
: 아키텍처의 공통적인 발생 문제에 대한 재사용 가능한 해결책

소프트웨어 아키텍처 패턴 종류
	1) 계층화 패턴(Layered Pattern)
		- N-티어 아키텍처 패턴으로 부른다
	2) 클라이언트-서버 패턴(Client-Server Pattern)
		- 다수의 클라이언트와 하나의 서버로 구성
	3) 마스터-슬레이브 패턴(Marster-Slave Pattern)
		- 마스터 컴포넌트가 슬레이브 컴포넌트로 작업 분산, 슬레이브가 결과값을 반환하면 최종 결과값 계산
	4) 파이프-필터 패턴(Pipe-Filter Pattern)
		- 데이터 스트림 생성
		- 서브시스템이 입력데이터를 받아 처리하고 결과를 다음 서브시스템으로 넘겨주는 과정을 반복
	5) 브로커 패턴(Broker Pattern)
		- 분산 시스템에서 사용되는 패턴
	6) 피어 투 피어 패턴(Peer to Peer Pattern) ::토렌트
		- 각 컴포넌트 간에 서비스(데이터)를 주고받는 패턴
	7) 이벤트-버스 패턴(Event-Bus Pattern) ::카카오채널
		- 이벤트 버스를 통해 특정 채널로 메시지를 발행
	8) 모델-뷰-컨트롤러 패턴(MVC, Pattern, Model-View-Controller Pattern)
		- 모델 : 도메인의 기능과 자료를 저장
		- 뷰 : 사용자에게 결과를 표시
		- 컨트롤러 : 사용자로부터 입력을 받아 연산을 처리
	9) 블랙보드 패턴(Blackboard Pattern)
		- 해결 전략이 알려지지 않은 문제에 대해서 유용한 패턴
	10) 인터프리터 패턴(Interpreter Pattern)
		- 특정 언어를 해석하는 컴포넌트를 설계할 때 사용하는 패턴

UML(Unified Modeling Language) ::그림 그리는 언어
: 시스템 개발 과정에서 이해관계자 사이에 의사소통을 원활하게 이루어지게 하기 위하여 표준화한 모델링 언어

UML 특징
	1) 가시화 언어
	2) 명세화 언어
	3) 구축 언어
	4) 문서화 언어

UML 구성요소
	1) 사물(Things)
		- 구조사물
		- 행동사물
		- 그룹사물
		- 주해사물
	2) 관계(Relationships)
		ㄱ. 일반화 관계(Generalization)
			- 한 클래스가 다른 클래스를 포함하는 상위 개념일 때 (상속관계)
			- 가전제품 (세탁기, TV, 식기세척기)
		ㄴ. 연관 관계(Association)
			- 한 클래스가 다른 클래스에서 제공하는 기능을 사용할 때
			- 사람 -> 휴대폰
		ㄷ. 의존 관계(Dependency)
			- 한 클래스가 다른 클래스에서 제공하는 기능을 사용할 때(매우 짦은 시간)
			- 학생 -> 색연필
		ㄹ. 실체화 관계(Realization)
			- 추상 메서드를 오버라이딩 하는것을 의미
			- 리모콘 틀 (선풍기 리모콘, TV 리모콘)
		ㅁ. 집합 관계 - 집약관계(Aggregation)
			- 한 객체가 다른 객체를 소유하는 관계
			- 전체 객체가 사라진다 해도 부분 객체는 사라지지 않음(독립적)
			- 불고기 (간장, 다시다, 미원)
		ㅂ. 집합 관계 - 합성관계(Composition)
			- 부분 객체가 전체 객체에 속하는 관계로 긴밀한 필수적 관계(의존적)
			- 책상 (책상다리, 상판, 나사)
	3) 다이어그램(Diagram)
		ㄱ. 구조 다이어그램
			종류			설명
			클래스 다이어그램		속성과 클래스 사이의 관계 표현
			객체 다이어그램		객체와 객체 사이 관계 표현
			컴포넌트 다이어그램	컴포넌트 사이 관계 표현
			배치 다이어그램		물리적 요소들의 위치 표현
			복합체 다이어그램		클래스나 컴포넌트가 복합구조를 가질 시
			패키지 다이어그램		요소들을 그룹화한 패키지들의 관계 표현
		ㄴ. 행위 다이어그램
			종류			설명
			유스케이스 다이어그램	사용자의 요구를 분석
			시퀀스 다이어그램		어떠한 순서로 어떤 객체와 상호작용하는지 표현
			커뮤니케이션 다이어그램	객체들이 주고받는 메시지 표현
			상태 다이어그램		클래스의 상태변화 표현
			활동 다이어그램		로직이나 조건에 따른 처리흐름을 순서에 따라 표현
			상호작용 다이어그램	상호작용 다이어그램 간 제어 흐름 표현
			타이밍 다이어그램		시간 제약을 명시적으로 표현

주요 다이어그램

클래스 다이어그램
: 속성과 일정한 행동으로 구성

	- 접근 제한자 표기법
		표기법	접근 제한자	사용범위
		-	private		해당 클래스 내에서만 접근 가능
		#	protected	상속, 동일 패키지 내에서만 접근 가능
		+	public		어디서든 접근 가능

유스케이스 다이어그램
: 시스템과 사용자의 상호작용을 다이어그램으로 표현

유스케이스 다이어그램 구성요소
	1) 시스템 : 만들고자 하는 프로그램 명칭
	2) 액터 : 시스템의 외부에 있고 시스템과 상호작용을 하는 사람, 시스템을 표현
	3) 유스케이스 : 사용자 입장에서 바라본 시스템의 기능
	4) 관계 : 액터와 유스케이스 사이의 의미있는 관계

유스케이스 다이어그램 관계
	1) 연관관계
		- 유스케이스와 액터 간의 상호작용이 있음을 표현
		- 실선으로 연결
	2) 포함관계
		- 유스케이스를 수행할 때 반드시 실행되어야 하는 경우
		- 점선 + <<Include>>
	3) 확장 관계
		- 유스케이스를 수행할 때 특정 조건에 따라 확장 기능 유스케이스를 수행하는 경우
		- 점선 + <<extend>>
	4) 일반화 관계
		- 유사한 유스케이스 또는 액터를 모아 추상화한 유스케이스

시퀀스 다이어그램
: 객체 간의 상호작용 메시지 시퀀스를 시간의 흐름에 따라 나타내는 다이어그램

시퀀스 다이어그램 구성요소
	- 객체와 생명선
	- 활성 박스
	- 메시지
		유형		설명
		동기 메시지	요청을 보낸 후에 반환이 올 때까지 대기
		비동기 메시지	요청을 보낸 다음 반환을 기다리지 않고 다른 작업을 수행
		자체 메시지	자기 자신에게 요청을 보냄
		반환 메시지	요청에 대해 메시지를 반환

상태 다이어그램
: 한 객체의 상태 변화를 나타내는 다이어그램
	결제 준비	--------------------> 결제 대기 ------------------> 결제 완료
		    결제정보 입력		   결제정보 일치
		↖		     ↓
		결제 재시도	결제 실패

04 화면 설계

UI
: 정보기기와 사용자가 서로 상호작용을 할 수 있도록 연결해주는 매개체

UX
: UI를 직/간접적으로 이용하여 경험한 모든 것

UI 유형
	1) CLI(Command Line Interface) : 컴퓨터 자판으로 명령을 입력하여 조작하는 시스템
	2) GUI(Graphical User Interface) : 그래픽과 텍스트로 이루어져 있어, 마우스로 입출력을 조작하는 시스템
	3) NUI(Natural User Interface) : 인간의 자연스러운 움직임을 인식하여 정보를 제공
	4) OUI(Organic User Interface) : 현실의 모든 것이 입출력 장치가 됨
	5) AUI(Auditory User Interface) : 임베디드 사운드

UI 설계
	1) 기능적 요구사항 : 기능에 대한 요구사항
	2) 비기능적 요구사항 : 사용성, 효율성, 신뢰성, 유지보수성, 재사용성 등 품질에 관한 요구사항

UI 설계 원칙
	1) 직관성
	2) 유효성
	3) 학습성
	4) 유연성

UI 설계 도구
	1) 와이어프레임(Wireframe) : 선으로 틀을 잡는다는 뜻
	2) 스토리보드 : 최종 결과를 예상할 수 있는 기초 문서
	3) 프로토타입 : 실제 서비스와 흡사한 모형을 만드는 작업, 동적인 효과 적용
	4) 목업 : 와이어프레임보다 좀 더 실제 화면과 유사하게 만든 정적인 형태의 모형
	5) 유스케이스 : 사용자 측면의 요구사항

감성공학
: 인간의 심상을 구체적인 물리적 설계 요소로 번역하여 이를 실현하는 기술

화면 레이아웃 구성
	1) 레이아웃 : 특정 공간에 여구 구성 요소를 효과적으로 배치하는 작업
	2) HTML5 : 웹페이지의 기본 구조를 담당
	3) CSS : 디자인 요소를 담당
	4) JavaScript : 웹 문서에 삽입해서 사용하는 스크립트 언어
		- React : 페이스북에서 개발
		- Vue.js : Evan You에 의해 개발
		- AngularJS : 구글에서 개발
		- Node.js : 서버 사이드 개발에 사용되는 소프트웨어 플랫폼
		- Ajax : 비동기적인 웹 애플리케이션의 제작을 위한 웹 개발 기법

UI 관련 용어
	용어		설명
	웹 표준		월드 와이드 웹의 측면을 서술하고 정의하는 공식 표준이나 다른 기술 규격
	웹 호환성		이용자의 단말기의 HW 및 SW 환경이 다른 경우에도 동등한 서비스 제공
	웹 접근성		장애인과 비장애인 모두가 동등하게 웹 사이트 이용
	반응형 웹		PC, Mobile 등 다양한 디바이스에서 화면 크기를 맞춰 사이트 제공
	인포그래픽	정보+그래픽, 아이콘,이미지 등을 활용하여 시각화한 것
	브랜드 아이덴티티	특정 브랜드의 가치와 의미를 반영한 심적 표상
	내비게이션	웹 사이트를 탐색하기 위한 도구
	아코디언		원하는 정보만 선택적으로 볼 수 있게 접을 수 있는 내용 패널
	플레이스 홀더	값을 입력하는 데 참고할 수 있도록 제공되는 간략한 텍스트 도움말
	필터링		원하지 않는 데이터 차단
	입력 폼		사용자가 웹 서버로 전송할 정보를 입력할 수 있는 웹 문서의 일부
	입력 필드		정보 입력에 사용되는 인터페이스 요소 (입력 폼의 일부)
	썸네일		커다란 이미지를 축소하여 제공한 이미지
	레이블		입력폼을 구성하는 다양한 입력 필드를 식별하기 휘해 사용하는 명칭
	대체 텍스트	콘텐츠를 대신하기 위해 제공되는 텍스트
	초점		사용자가 선택한 해당 요소 (커서)

05 서버 프로그램 구현

서버 환경 구축
	1) 웹 서버(WEB)
		- 클라이언트에게 정적 파일을 제공하는 웹 서버 애플리케이션이 설치된 하드웨어
		- Apache Web Server, IIS, Nginx, GWS 등
	2) 웹 애플리케이션 서버(WAS)
		- 동적인 웹 서비스를 제공하기 위한 미들웨어가 설치된 하드웨어
		- WebLogic, WebSpere, Jeus, Tomcat 등
	3) 데이터베이스 서버(DBMS)
		- 데이터의 저장과 관리를 위한 DB 소프트웨어가 설치된 하드웨어
		- Oracle, MySQL, MS-SQL 등
	4) 파일서버 ::첨부파일
		- 사용자의 파일을 저장하고 공유할 목적으로 구성된 하드웨어
	5) Load Balancer
		- 여러 대의 서버가 존재할 경우 요청을 적절히 분배해주는 역할
			종류		설명
			Random		요청을 랜덤으로 분배한다.
			Least loaded	가장 적은 양의 작업을 처리하고 있는 서버에게 요청 할당
			Round Robin	순서를 정하여 돌아가며 작업 분배
	6) CDN(Content Delivery Network) ::유튜브
		- 사용자와 가까운곳에 분산되어 있는 데이터 저장 서버

개발 소프트웨어 환경

시스템 소프트웨어
	1) 운영체제(OS)
		- 하드웨어 운영을 위한 운영체제
		- Windows, Linux, UNIX 등의 환경으로 구성
	2) JVM(Java Virtual Machine)
		- JAVA 관련 프로그램을 기동하기 위한 환경
	3) Web Server
		- 정적 웹 서비스를 수행하는 미들웨어
	4) WAS(Web Application Server)
		- 동적 웹 서비스를 수행하는 미들웨어
	5) DBMS
		- 데이터 저장과 관리를 위한 데이터베이스 소프트웨어

개발 소프트웨어
	1) 요구사항 관리 도구
	2) 설계/모델링 도구
	3) 구현 도구
	4) 테스트 도구
	5) 형상관리 도구
		- 소스코드의 변경사항을 버전별로 관리, 품질 향상을 지원하는 도구
		- Git, CVS, SVN 등

IDE(Intergrated Development Environment) 도구
: 많은 도구의 기능을 하나로 묶어 활용하는 소프트웨어

IDE 도구의 종류
	- 이클립스
	- 비주얼 스튜디오
	- 엑스코드
	- IntelliJ IDEA

협업 도구
: 통합된 하나의 프로젝트를 동시에 수행할 수 있도록 도와주는 소프트웨어

형상 관리 도구
: 소프트웨어의 변경사항을 체계적으로 관리하는 것

	1) 변경 관리
		- 소스의 변경 사항을 관리
	2) 버전 관리
		- 변경을 관리하기 위한 효과적인 방법
	3) 형상 관리
		- 변경 관리와 버전 관리가 포함되고, 빌드와 릴리즈까지 모두 관리할 수 있는 통합 시스템

형상 관리 절차 (식.도.감.기)
	1) 형상 식별
	2) 형상 통제
		- 소프트웨어 형상 변경 요청을 검토하고 승인하여 현재의 베이스라인에 반영될 수 있도록 통제
	3) 형상 감사
	4) 형상 기록/보고

버전 관리 도구
: 동일한 소스코드에 대한 여러 버전을 관리하는 것

버전 관리 도구 유형
	1) 공유 폴더 방식(RCS, SCCS) ::미친짓
		- 개발이 완료된 파일을 매일 약속된 위치의 공유 폴더에 복사
	2) 클라이언트/서버 방식(CVS, SVN)
		- 중앙에 버전 관리 시스템이 항시 동작
	3) 분산 저장소 방식(Git)
		- 로컬 저장소와 원격 저장소 구조

버전 관리 도구별 특징
	1) CVS
		- 오랜 기간 사용된 형상 관리 도구, 다양한 운영체제 지원
	2) SVN
		- CVS의 단점 보완, 원본과의 차이점을 저장하는 방식
	3) Git
		- 리누스 토발즈, 원격 Repository에 장애가 있어도 버전 관리가 가능하다
	4) Clear Case
		- IBM에서 개발
	5) BitKeeper
		- SVN과 비슷
	6) RCS(Revision Control System)
		- 소스 파일의 수정을 한 사람만으로 제한

버전 관리 주요 용어
	용어		설명
	Repository	저장소
	Checkout		Repository에서 로컬로 프로젝트를 복사
	Commit		로컬의 변경된 내용을 Repository에 저장
	Update		Repository에 있는 내용을 로컬에 반영
	Add		로컬에서 새로운 파일이 추가되었을 때 Repository에 등록
	Trunk		Root 프로젝트
	Branch		Root 프로젝트에서 파생된 프로젝트
	Merge		Branch에서 진행하던 작업을 Root 프로젝트와 합침
	Diff		파일의 비교

빌드 도구
: 소스코드 파일들을 소프트웨어로 변환하는 일련의 과정

빌드 자동화 도구 특징
	- 빌드, 테스트, 배포를 자동으로 수행하는 도구

개발자	  Commit				테스트 서버  실 서버
	    ↘					↖↗	
개발자 ---------------> 형상관리 서버 ----------------> CI 서버 ------------------> 빌드 스크립트
	    ↗			    Polling		Checkout
개발자	  Commit

빌드 자동화 도구 종류
	1) Make
		- 유닉스 계열 운영체제
	2) Ant
		- Java 기반, 역사가 오래되었다.
	3) Maven
		- 의존성을 리스트 형태로 Maven에게 알려 돕는 방식
	4) Jenkins
		- Java 기반, SVN, Git 연동 가능
	5) Gradle
		- 안드로이드 앱 개발 환경에서 사용

프레임워크
: 손쉽게 구현할 수 있도록 여러가지 기능들을 제공해주는 반제품 형태의 소프트웨어

프레임워크 특징
	- 모듈화
	- 재사용성
	- 확장성
	- 제어의 역흐름

라이브러리 ::언어에 종속적
: 빈번하게 사용되는 루틴 또는 리소스를 모아둔 것

API
: 일종의 소프트웨어 인터페이스, 다른 종류의 소프트웨어에 서비스 제공

단위 모듈 구현
: 소프트웨어를 기능 단위로 분해하여 구현하는 기법

효과적인 모듈화
	- 결합도를 낮추고 응집도를 높여 모듈의 독립성을 높임

단위 모듈 작성 원칙 (정.명.완.일.주(추))
	- 정확성
	- 명확성
	- 완전성
	- 일관성
	- 추적성

결합도(Coupling)
: 두 모듈 사이의 연관 관계, 낮을수록 잘 설계된 모듈이다.
	구분			설명
	자료 결합도		인수로 (값)이 전달되는 경우
	(Data Coupling)
	스탬프 결합도		인수로 (배열)이나 (주소값)이 전달되는 경우
	(Stamp Coupling)
	제어 결합도		(제어 요소)가 전달되는 경우(If문)
	(Control Coupling)
	외부 결합도		데이터를 (외부)의 다른 모듈에서 참조하는 경우(External)
	(External Coupling)
	공통 결합도		(전역 변수)를 참조하고 있는 경우
	(Common Coupling)
	내용 결합도		다른 모듈 내부의 변수나 기능을 다른 모듈에서 사용하는 경우(스파게티 코드)
	(Content Coupling)

응집도
: 모듈의 독립성을 나타내는 개념, 내부 구성요소 간 연관정도, 높을수록 잘 설계된 모듈
	구분			설명
	기능적 응집도		내부의 모든 기능이 단일한 목적을 위해 수행되는 경우
	(Functianal Cohesion)
	순차적 응집도		한 활동으로부터 나온 출력값을 다른 활동이 사용할 경우
	(Sequential Cohesion)
	통신적 응집도		동일한 입력과 출력을 사용하는 경우
	(Communication Cohesion)
	절차적 응집도		모듈 안의 구성 요소들이 그 기능을 순차적으로 수행할 경우
	(Procedural Cohesion)
	시간적 응집도		특정 시간에 처리되어야 하는 활동들을 한 모듈에서 처리할 경우
	(Temporal Cohesion)
	논리적 응집도		유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들이 한 모듈에서 처리되는 경우
	(Logical Cohesion)
	우연적 응집도		각 구성 요소들이 연관이 없을 경우
	(Coincidental Cohesion)

팬인(Fan-in)
: 해당 모듈로 들어오는 상위 모듈 수

팬아웃(Fan-out)
: 해당 모듈에서 호출하는 하위 모듈 수

공통 모듈 구현 순서
	DTO/VO 구현 -> SQL문 구현 -> DAO 구현 -> Service 구현 -> Controller 구현 -> 필요 시 화면 구현

Annotation ::@
	- 사전적으로는 "주석"이라는 의미를 가지고있다
	- 컴파일, 런타임에 해석된다.

서버 프로그램 구현

MVC 모델의 계층
	1) 프레젠테이션 계층
	2) 제어 계층
	3) 비즈니스 로직 계층
	4) 퍼시스턴스 계층
	5) 도메인 모델 계층

DBMS 접속기술
	1) 소켓통신 : 응용프로그램과 DBMS가 주고받는 통신
	2) Vender API : DBMS사에서 공개한 API를 이용해 DBMS와 통신
	3) JDBC(Java DataBase Connetivity) : Java에서 DB에 접속하고 SQL문을 수행할 때 사용되는 표준 API
	4) ODBC(Open DataBase Connectivity) : 데이터베이스에 접근하기 위한 표준규격

ORM(Object-Relational Mapping) 프레임워크 ::완전자동X, 반자동
: 객체와 데이터베이스의 데이터를 자동으로 매핑

매핑 기술 비교
	1) SQL Mapper
		- 단순히 필드를 매핑
		- iBatis, Mybatis, jdbc Templates 등
	2) OR Mapping(=ORM)
		- 객체를 통해 간접적으로 데이터베이스를 다룬다
		- JPA, Hibernate

시큐어 코딩

OWASP(The Open Web Application Security Project)
	- 오픈소스 웹 애플리케이션 보안 프로젝트

시큐어 코딩 가이드
	1) 입력 데이터 검증 및 표현
		종류			설명
		SQL Injection		SQL문을 삽입하여 DB를 조작할 수 있는 공격
		XSS			악의적인 스크립트를 포함해 실행되게 유도하는 공격
		(크로스 사이트 스크립트)
		자원 삽입			외부 입력값이 자원 접근 및 제어에 사용되는 공격
		위험한 형식 파일 업로드	스크립트 파일을 업로드하여 공격
		명령 삽입		(운영체제 명령어, XQuery, XPath, LDAP) 삽입
		메모리 버퍼 오버플로	버퍼를 넘치게 하여 버퍼 이후의 공간을 침범하는 공격
	2) 보안 기능
		종류			설명
		적절한 인증 없이		적절한 인증과정 없이 중요정보를 열람할때 발생하는 보안 약점
		중요기능 허용
		부적절한 인가		외부 입력값을 포함한 문자열로 중요 자원에 접근하는 보안 약점
		취약한 암호화		DES, MDS등 안전하지 않은 알고리즘 사용
		알고리즘 사용
		하드코딩된 패스워드	소스코드 내에 비밀번호가 하드코딩되어 있는 보안 약점
		패스워드 평문 저장	계정 정보 탈취 시 패스워드 노출
		취약한 패스워드 허용	비밀번호 조합규칙이 미흡하여 노출되는 보안 약점
	3) 시간 및 상태
		종류 			설명
		경쟁 조건			동일 자원에 대한 검사 시점과 사용 시점이 상이하여 동기화 오류, 교착상태 유발
		종료되지 않는 반복문	무한 루프에 빠져 자원 고갈을 유발
		또는 재귀 함수
	4) 에러 처리
		종류			설명
		오류 메시지 정보 노출	민감 정보가 오류 메시지를 통해 노출됨
		오류 상황 대응 부재	예외처리 미구현
		부적절한 예외 처리	프로그램 수행 중 예외 조건을 적절히 검사하지 않음
	5) 코드 오류
		종류			설명
		널 포인터 역참조		널 값을 고려하지 않은 코드
		부적절한 자원 해제	자원을 할당받아 사용한 뒤 반환하지 않은 코드
		해제된 자원 사용		해제한 메모리를 참조하는 코드
		초기화되지 않은 변수 사용	지역변수를 초기화하지 않고 사용하는 코드
	6) 캡슐화
		종류			설명
		잘못된 세션에 의한	멀티 스레드 환경에서 서로 다른 세션간 데이터가 공유
		정보 노출
		제거되지 않은 디버그 코드	배포 단계에 디버그 코드가 남아 있는 경우
		시스템 정보 노출		시스템 내부가 노출
		잘못된 접근 지정자	private, public 잘못된 접근 지정자 사용
	7) API 오용
		종류			설명
		DNS에 의존한 보안 결정	공격자가 DNS 정보를 변조하여 보안 결정 우회 가능함
		취약한 API 사용		금지되거나 안전하지 않은 함수를 사용

배치 프로그램
: 데이터를 일괄적으로 모아서 처리하는 대량의 작업을 처리

배치 프로그램의 필수 요소
	- 대용량 데이터
	- 자동화
	- 견고함
	- 안정성
	- 성능

스케줄 관리 종류
	1) 크론탭(crontab)
		- 분 시 일 월 요일 명령어
	2) Spring Batch
		- 백엔드의 배치처리 기능을 구현하는 데 사용하는 프레임워크
	3) Quartz Job Scheduler
		- 초 분 시 일 월 요일 년(생략가능)

06 인터페이스 구현

인터페이스 시스템
: 서로 다른 장치나 시스템 사이에서 정보나 신호를 주고받을 수 있도록 도움을 주는 프로그램

인터페이스 시스템 구성
	1) 송신 시스템
	2) 수신 시스템
	3) 중계 서버

내.외부 모듈 연계 방식

EAI(Enterprise Appication Integration)
: 기업에서 운영되는 서로 다른 플랫폼 및 App들 간의 정보 전달, 연계, 통합을 가능하게 해주는 솔루션
	1) Point-to-Point
		- 중간에 미들웨어를 두지 않고 각 App간 Point to Point 형태로 연결
	2) Hub & Spoke
		- 허브 시스템을 통해 데이터를 전송하는 중앙 집중적 방식
	3) Message Bus(ESB 방식)
		- 애플리케이션 사이 미들웨어(버스)를 두어 처리
	4) Hybrid
		- Hub & Spoke + 메시지 버스 방식

ESB(Enterprise Service Bus)
	- 버스를 통해 이기종 App을 유연하게 통합하는 핵심 플랫폼

인터페이스 연계 기술
	1) Link : DB에 제공하는 DB Link 객체를 이용
	2) DB Connection : WAS에서 DB로 연결하여 DB Connection Pool을 생성
	3) JDBC : JDBC 드라이버를 이용하여 송신 시스템 DB와 연결
	4) API / OpenAPI : 송신 시스템의 App 프로그래밍 인터페이스 프로그램
	5) Web Service : WSDL, UDDI, SOAP 프로토콜을 이용하여 연계
	6) Hyper Link : 하이퍼링크 이용
	7) Socket : 소켓을 생성하여 포트를 할당

인터페이스 전송 데이터
	1) JSON(JavaScript Object Notation)
		- JavaScript 객체 문법, 값/쌍 으로 이루진다
	2) XML(eXtensible Markup Language)
		- 웹에서 구조화한 문서를 표현하는 마크업 언어
	3) YAML
		- 직렬화 언어
	4) CSV(Comma Separated Values) ::엑셀 호환
		- 쉼표로 구분한 텍스트 데이터 및 파일

인터페이스 구현

AJAX
: JavaScript를 이용해 브라우저가 비동기 방식으로 데이터를 교환할 수 있는 통신 기능
	- 비동기 방식 : 웹페이지를 리로드하지 않고 데이터를 불러오는 방식

SOAP(Simple Object Access Protocol)
: HTTP, HTTPS, SMTP 등을 통해 XML 기반의 메시지를 컴퓨터 네트워크상에서 교환하는 프로토콜
	- 웹 서비스에서 기본적인 메시지를 전달하는 기반이 된다

SOAP의 구성
		UDDI
       WSDL↙		↘WSDL
서비스 사용자	↔	서비스 제공자
		SOAP

	1) SOAP : HTTP, HTTPS, SMTP 등을 사용하여 XML 기반의 메시지를 네트워크상에서 교환하는 형태의 프로토콜
		- 실제 통신 프로토콜
	2) UDDI : 인터넷에서 비즈니스 업체 목록에 자신의 목록을 등록하기 위한 XML기반의 규격
		- 도서관
	3) WSDL : 웹 서비스 기술 언어 또는 기술된 정의 파일이 총칭으로 XML로 기술
		- 설명서

REST
: HTTP URI를 통해 자원을 명시하고, HTTP Method(POST, GET, PUT, DELETE)를 통해 CRUD 연산을 적용하는 것

REST의 구성요소
	1) 자원, URI
		- 서버에 존재하는 데이터의 총칭
	2) 행위, Method
		- POST, GET, PUT, DELETE
	3) 표현
		- REST에서 하나의 자원은 JSON, XML, TEXT, RSS 등 여러 형태로 나타낼 수 있다.

CRUD Operation, HTTP Method
	- Create : POST(자원 생성)
	- Read : GET(자원 정보 조회)
	- Update : PUT(자원 정보 업데이트)
	- Delete : DELETE(자원 삭제)

REST 특징
	1) 유니폼 인터페이스
	2) Stateless(상태 정보 유지 안함)
	3) Cacheable(캐시가능)
	4) Self-descriptiveness(자체 표현 구조)

RESTful
: REST의 원리를 따르는 시스템

인터페이스 보안 기능 적용
	1) 네트워크 영역
		- IPSec, SSL, S-HTTP
	2) 애플리케이션 영역
		- 시큐어코딩 가이드 참조하여 코드상 보안 취약점 보완
	3) DB 영역
		- DB, 스키마, 엔티티의 접근 권한과 프로시저, 트리거 등 DB 동작 객체에 보안 기능을 적용

인터페이스 구현 검증 도구
	1) xUnit : 다양한 언어를 지원
	2) STAF : 서비스 호출 및 컴포넌트 재사용
	3) FitNesse : 웹 기반 테스트케이스 설계, 실행, 결과 확인
	4) NTAF : Fit(N)esse + STAF, Naver 개발 -> 폐쇄
	5) Selenium : 웹 애플리케이션 테스트 프레임워크
	6) watir : (R)uby 사용

07 객체지향 구현

객체지향(OOP, Object Oriented Programming)
: 현실 세계의 유형, 무형의 모든 대상을 객체로 나누고, 객체의 행동과 고유한 값을 정의하여 설계하는 방법

객체지향 구성요소
	1) 클래스
	2) 객체
	3) 속성
	4) 메서드
	5) 메시지

객체지향언어의 특징
	1) 캡슐화
	2) 정보은닉
	3) 상속
	4) 다형성
	5) 추상화

객체지향 설계원칙(SOLID)
	1) 단일책임 원칙(SRP) : 한 클래스는 하나의 책임만을 가져야한다.
	2) 개방폐쇄 원칙(OCP) : 수정에는 닫혀 있고, 확장에는 열려 있어야한다. (기존코드 수정X)
	3) 리스코프 치환 원칙(LSP) : 자식은 언제나 부모를 대체할 수 있어야 한다.
	4) 인터페이스 분리 원칙(ISP) : 사용하지 않는 인터페이스는 구현하지 말아야 한다.
	5) 의존성 역전 원칙(DIP) : 변화가 거의 없는 것에 의존해야 한다.

디자인패턴
: 재사용할 수 있도록 만들어놓은 패턴들의 모음

GoF 디자인 패턴
	- 생성 패턴 : 객체 생성과 관련 패턴
	- 구조 패턴 : 더 큰 구조를 만드는 패턴
	- 행위 패턴 : 알고리즘이나 책임 분배에 관련된 패턴

디자인 패턴 종류
	1) 생성 패턴
		- 추상 팩토리(Abstract Factory) : 구체적인 클래스에 의존 X, 추상적
		- 빌더(Builder) : 객체 생성시 생성,표현 분리
		- 팩토리 메서드(Factory Method) : 서브클래스 위임 후 캡슐화
		- 프로토타입(Prototype) : 원본 객체 복사, clone()
		- 싱글톤(Single-ton) : 인스턴스는 하나(싱글)임을 보장
	2) 구조 패턴
		- 어댑터(Adaptor) : 변환 (220V -> 110V)
		- 브리지(Bridge) : 추상화+오버라이딩
		- 컴포지트(Composite) : 복합 객체, 단일 객체 구분X
		- 데코레이터(Decorator) : 어떤 객체에 다른 객체를 덧붙이는 방식
		- 퍼사드(Facade) : 서브시스템 가장 앞단에서 서브시스템의 객체들을 사용
		- 플라이웨이트(Fly Weight) : 메모리 절약
		- 프록시(Proxy) : 객체의 대리 제공(푸틴)
	3) 행위 패턴
		- 책임 연쇄(Responsibility-Chain) : 객체를 만날 때 까지 Chain을 따라 요청을 전달
		- 커맨드(Command) : 요청을 캡슐화
		- 인터프리터(Interpreter) : 특정 언어
		- 반복자(Iterator) : 객체의 원소를 순차적으로 접근
		- 중재자(Mediator) : 상호작용을 캡슐화 
		- 메멘토(Mementor) : 실체화
		- 옵저버(Observer) : 변화를 통지받고 자동으로 갱신(감시)
		- 상태(State) : 동일한 동작을 다르게 처리
		- 전략(Strategy) : 알고리즘
		- 템플릿 메소드(Template Method) : 상위클래스 -> 골격, 서브시스템 -> 처리 (추상화)
		- 방문자(Visitor) : 개방폐쇄원칙

08 애플리케이션 테스트 관리

소프트웨어 테스트
: 소프트웨어의 결함을 찾아내는 활동

소프트웨어 테스트의 필요성
	- 오류 발견 관점
	- 오류 예방 관점
	- 품질 향상 관점

소프트웨어 테스트의 기본 원칙
	- 결함 집중(Defect Clustering)
		ㄱ. 파레토 법칙 : 전체 결과의 80%가 전체 원인의 20%에서 일어나는 현상
		ㄴ. 살충제 패러독스(Preticide Paradox)
		    : 동일한 테스트 케이스로 반복 실행하면 결함을 발견할 수 없으므로 주기적으로 테스트케이스 개선
	- 오류-부재의 궤변 : 사용자의 요구사항을 만족하지 못하면 오류를 제거하였더라도 품질이 높다고 말할 수 없다.

테스트 오라클
: 테스트 결과가 참인지 거짓인지를 판단하기 위해서 사전에 정의된 '참'값을 입력하여 비교하는 기법

테스트 오라클의 유형
	1) 참 오라클(True)
		- 모든 테스트 케이스 입력 결과를 확인
	2) 샘플링 오라클(Sampling)
		- 특정한 몇 개의 입력 값에 대해서만 결과 제공
	3) 휴리스틱 오라클(Heuristic)
		- 샘플링 오라클을 개선, 특정 값 이외 나머지에 대해서는 휴리스틱(추정)으로 처리
	4) 일관성 검사 오라클(Consistent)
		- 수행 전과 후의 결과 값이 동일한지 확인

테스트 레벨
	1) 단위테스트 : 테스트 프로젝트의 첫 단계
		- 정적, 동적 테스트
	2) 통합테스트 : 컴포넌트 간의 상호작용 과정의 오류를 발견하는 작업 수행
		- 상향식, 하향식, 빅뱅, 백본 테스트
	3) 시스템테스트 : 구현된 시스템과 계획된 사양을 서로 비교하는 작업
		- 기능, 비기능 테스트
	4) 인수테스트 : 배포 또는 사용할 준비가 되었는지 평가
		- 알파, 베타(필드) 테스트

소프트웨어 테스트 기법

프로그램 실행 여부
	1) 정적 테스트 : 소프트웨어의 실행 없이 소스코드의 구조를 분석하여 논리적으로 검증하는 테스트
	2) 동적 테스트 : 소프트웨어를 실행하여 실제 발생하는 오류를 발견하여 문제를 해결하는 분석 기법

테스트 기법
	1) 화이트박스 테스트 : 소프트웨어 내부 구조와 동작을 검사하는 방식
		- 문장 검증 : 모든 문장을 한 번 수행하여 검사
		- 선택(분기) 검증 : 선택한 부분만 검사
		- 경로 검증 : 모든 경로 검사
		- 조건 검증 : 조건식 검사
	2) 기초 경로 검사(Basic Path Test) : McCabe 제안, 화이트박스 테스트 기법
		결과값 = 선 개수 - 노드 개수 +2 	->	면 개수 + 1

	3) 블랙박스 테스트 : 명세를 보면서 구현된 기능을 테스트
		- 동등 분할 기법 : 80 ~ 90의 조건이면 중간치 95 검사
		- 경계값 분석 : 80~90의 조건이면 79,80,81,89,90,91 검사
		- 원인효과 그래프 검사 : 효용성이 높은 테스트 케이스 선정
		- 오류 예측 검사 : 경험 또는 감각으로 테스트
		- 비교 검사 : 여러 버전의 동일한 테스트 자료를 제공하여 동일한 결과가 출력되는지 테스트

테스트에 대한 시각
	1) 검증(Verification) : 개발 과정 테스트 -> 개발자
	2) 확인(Validation) : 완성된 소프트웨어 테스트 -> 사용자

테스트 목적
	목적		설명
	회복(Recovery)	고의로 실패를 유도하고 정상적으로 복귀하는지 테스트
	안전(Security)	보안적인 결함을 미리 점검하는 테스트
	강도(Stress)	과부하 시에도 시스템이 정상적으로 작동되는지 테스트
	성능(Performance)	응답 시간, 처리량, 반응속도 등을 테스트
	구조(Structure)	내부 논리 경로, 소스코드의 복잡도를 평가
	회귀(Regression)	변경 또는 수정된 코드에 대하여 새로운 결함 발견 여부 테스트
	병행(Parallel)	기존 시스템과 변경 시스템에 데이터를 입력 후 결과를 비교하는 테스트
	A/B 테스트	새로운 서비스(A)가 기존(B)에 비해 정말 효과가 있는지 알아보는 테스트
	스모크 테스트	테스트에 앞서 테스트 환경의 테스트가 가능한지 여부 판단하기 위한 간단 테스트

테스트 종류
	1) 명세 기반 테스트 : 명세를 빠짐없이 구현하고 있는지
	2) 구조 기반 테스트 : 논리 흐름에 따라 작성하고 확인
	3) 경험 기반 테스트 : 경험 많은 테스터의 직관과 능력을 기반으로 테스트

테스트 커버리지
: 테스트를 얼마나 수행했는지 측정하는 기준

테스트 커버리지 유형
	1) 기능 기반 커버리지 : 수행 된 기능수 / 전체 기능수
	2) 라인 커버리지 : 수행 된 라인 수 / 전체 라인 수
	3) 코드 커버리지 : 소스코드의 구문, 조건, 결정 등의 코드 구조가 얼마나 테스트 되었는지 측정
		ㄱ. 구문 커버리지 : 모든 구문에 대해 한 번 이상 수행
		ㄴ. 조건 커버리지 : 개별조건식이 각각, T/F를 만족하면 된다
		ㄷ. 결정 커버리지 : 결정포인트가 각각, T/F를 만족하면 된다.
		ㄹ. 조건/결정 커버리지 : 결정포인트 T/F, 개별조건식 T/F 만족해야 한다.
		ㅁ. 변경 조건/결정 커버리지 : 모든 결정포인트내의 개별조건식은 적어도 한 번 T/F를 가져야 한다.
		ㅂ. 다중 조건 커버리지 : 결정포인트 내 모든 개별조건식의 가능한 조합을 100% 보장해야 한다.

결함관리 도구 ::게시판
: 결함을 추적하고 관리할 수 있게 해주는 도구

결함관리 프로세스
	- 에러 발견
	- 에러 등록
	- 에러 분석
	- 결함 확정
	- 결함 할당
	- 결함 조치
	- 결함 조치 검토 및 승인

테스트 자동화 도구
: 테스트 작업을 스크립트 형태로 구현하여 테스트 반복 수행

테스트 자동화 도구 유형
	- 테스트 장치(Test Harness) : App 컴포넌트 및 모듈을 테스트하는 환경의 일부분, 테스트 지원하기 위한 코드와 데이터
		구성요소			설명
		테스트 드라이버		상향식 테스트에 필요
		테스트 스텁		하향식 테스트에 필요
		테스트 슈트		테스트 케이스의 집합
		테스트 케이스		입력값, 실행조건, 기대결과의 집합
		테스트 스크립트		명세
		목 오브젝트		조건부로 사전에 입력해 두면, 행위를 수행하는 객체

통합 테스트
: 단위테스트 이후 모듈을 통합하는 과정에서 오류를 찾는 테스트 기법

통합 테스트 수행 방법의 분류
	- 점증적 방식 : 상향식 통합 테스트, 하향식 통합 테스트 -> 합치면 백본 테스트
	- 비 점증적 방식 : 빅뱅 테스트
		1) 하향식 통합 테스트(Top-Down)
			- 메인 모듈부터 아래 방향으로 진행
			- '깊이-우선' 또는 '너비-우선'방식으로 통합
			- 스텁(Stub)을 개발하여 테스트 진행
		2) 상향식 통합 테스트(Bottom-Up)
			- 최하위 모듈부터 위쪽 방향으로 진행
			- 하위 모듈을 클러스터로 결합하면서 위쪽 방향으로 진행
			- 드라이버(Driver)를 개발하여 테스트 진행
		3) 빅뱅 테스트
			- 모든 구성 요소들을 한꺼번에 통합하여 테스트
		4) 백본 테스트
			- 샌드위치 테스트
			- 상향식과 하향식의 장점을 이용하는 방식
			- 드라이버/스텁을 필요에 따라 만들어 사용

애플리케이션 성능 분석

성능 분석 지표
	- 처리량
	- 응답 시간
	- 경과 시간
	- 자원 사용률

성능 분석 도구
	1) JMeter
	2) LoadUI
	3) OpenSTA

모니터링 도구
	1) Scouter : 단일 뷰
	2) NMon : 리눅스 서버 지원
	3) Zabbix : 웹 기반
	4) Jeniffer : 트랜잭션 수량, 처리시간, 응답시간, 자원 활용률 모니터링(고가)

FTR
: 소프트웨어 엔지니어가 수행하는 소프트웨어 품질 보증 활동

소스코드 품질 분석
	1) 동료 검토(Peer Review)
		- 2~3명이 진행
	2) 워크스루(Walkthrough) ::팀회의
		- 계획된 개발자 검토 회의
		- 회의 전 자료 배포
	3) 인스펙션(Inspection)
		- 다른 전문가 또는 팀이 검사하는 가장 공식적인 리뷰 기법
		- 계획 -> 사전교육 -> 준비 -> 인스펙션 회의 -> 수정(리팩토링) -> 후속조치

소스코드 품질 분석 도구
: 코딩을 하면서 발생하는 문제를 해결하기 위해 사용하는 도구

소스코드 품질 분석 도구 종류
	1) 정적 분석 도구
		- PMD
		- SonarQube
		- checkstyle
		- cppcheck
		- ccm
	2) 동적 분석 도구
		- Avalanche
		- Valgrind

코드 최적화
: 소스코드 리팩토링을 통해서 코드 스멜을 제거한다.

코드 스멜
: 코드에서 더 심각한 문제를 일으킬 가능성이 있는 소스코드
	- 스파게티 코드
	- 외계인 코드

리팩토링
: 외부 동작을 바꾸지 않으면서 내부 구조를 개선하는 방법

클린 코드
: 의존성을 최소화하고, 가독성, 목적성이 뛰어난 명확한 코드

클린 코드 작성 원칙
	- 가독성 : 누구든지 읽을 수 있게
	- 단순성 : 코드를 간단하게
	- 의존성 배제 : 다른 모듈에 미치는 영향 최소화
	- 중복성 최소화 : 코드의 중복 최소화
	- 추상화 : 상위 객체는 간략하게, 하위 객체는 상세하게 구현

09 소프트웨어 유지보수

유지보수
: 개발 완료 시점부터 폐기될 때까지, 지속적으로 수행하는 작업

유지보수의 구분
	1) 수정 보수 : 잠재적인 오류를 찾아 수정
	2) 적응 보수 : 환경 변화에 맞추기 위해 수행
	3) 향상 보수 : 새로운 기능 추가 및 기존 기능 개선
	4) 예방 보수 : 선제적으로 하는 유지 보수

유지보수 관련 용어
	1) 레거시 시스템 : 낡은 기술
	2) 외계인 코드 : 오래되거나 참고 문서 또는 개발자가 없어 유지보수가 어려운 코드 -> 역공학 필요
	3) 스파게티 코드 : 복잡한 프로그래밍 소스코드

10 소프트웨어 패키징

제품 품질 국제 표준
: 개발 공정 각 단계에서 제품이 사용자 요구를 만족하는지 검증하기 위한 국제 표준

품질 관련 국제 표준(ISO/IEC)
	- 9126 : 품질 -> 기능성, 신뢰성, 사용성, 효율성, 유지보수성, 이식성
	- 14598 : 평가프로세스 -> 반복성, 공정성, 객관성, 재현성
	- 12119 : 품질 + 테스트
	- 25000 : 통합모델 (9126 + 14598)

프로세스 품질 국제 표준
: 프로세스 관리 능력을 평가하고 개선하는 데 활용할 수 있는 국제 표준

국제 프로세스 품질 표준(ISO/IEC)
	- 9001 : 조직의 품질 보증
	- 12207 : 생명주기 (기본, 지원, 조직)
	- 15504(SPICE) : 불안정, 수행, 관리, 확립, 예측, 최적화
	- CMM : 초기, 반복, 정의, 관리, 최적화 (반.정.관) 2->관리, 3->표준, 4->정량적
	- CMMi : 초기, 관리, 정의, 정량적 관리, 최적화 (관.정.정) 2->관리, 3->표준, 4->정량적
	
서비스관리 국제 표준
: 고객에게 IT 서비스를 제공하고 관리체계를 적용하여 적절한 통제, 개선된 효과성 및 개선을 제공

국제 서비스 관리 표준(ISO/IEC)
	- 20000 : IT서비스의 수준을 객관적으로 평가

애플리케이션 패키징
: 고객에게 전달하기 위한 형태로 패키징하고, 매뉴얼을 작성하는 활동

패키징 특징
	- 사용자 중심으로 진행

애플리케이션 배포
: 최종 사용자에게 소프트웨어를 전달하는 과정

CI/CD
	1) CI(Continuous Intergration) : 지속적인 통합 -> 정기적으로 레포지토리에 통합
	2) CD(Continuous Delivery & Continuous Deployment) : 지속적인 제공 및 배포

릴리즈 노트 ::매뉴얼
: 소프트웨어 제품과 함께 배포되는 문서

DRM ::영화관
: 콘텐츠 사용을 저작권 소유자의 의도에 따라 제어하는 기술
	구성			설명
	콘텐츠 제공자(영화감독)	저작권자
	콘텐츠 분배자(영화관)	쇼핑몰 등으로써 암호화된 콘텐츠 제공
	패키저			콘텐츠를 배포 가능한 단위로 묶는 기능
	보안 컨테이너		원본을 안전하게 유통하기 위한 전자적 보안 장치
	DRM 컨트롤러		배포된 콘텐츠의 이용 권한 통제
	클리어링 하우스(CGV본사)	키 관리 및 라이선스 발급 관리

		워터마킹		핑거프린팅
목적		불법 복제 방지	불법 유통 방지
삽입정보		저작권 정보	저작권 정보 + 구매자 정보



























