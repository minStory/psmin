소프트웨어 생명 주기
: 소프트웨어 개발 방법론의 바탕이 되며 소프트웨어를 개발하기 위해 정의하고
  운용 유지보수 등의 과정을 각 단계별로 나눈 것
	- 소프트웨어 개발 단계와 각 단계별 주요 활동 및 활동의 결과를 산출물로써 표현
	- 소프트웨어 생명 주기를 표현하는 형태를 소프트웨어 생명 주기 모형,
	  소프트웨어 프로세스 모형, 소프트웨어 공학 패러다임 이라고 함
	- 특정 모형을 선택하여 사용하거나 개별적인 모형을 사용할 수 있음

폭포수 모형(Waterfall Model)
: 폭포수가 거슬러 올라갈 수 없듯이 이전 단계를 확실히 마무리하고 다음 단계로 진행하는 개발 방법론
	- 소프트웨어 공학에서 가장 오래되고 폭넓게 사용된 생명 주기 모형
	- 한 단계가 끝나야 다음 단계로 넘어갈 수 있는 선형 순차적 모형
	- 매뉴얼을 작성해야 함
	- 단계를 끝내고 다음 단계로 가기 위해서는 결과물이 명확히 나와야함
	[순서]
	타당성에 대해 검토 -> 계획 -> 요구 분석 -> 설계 -> 구현(프로그래밍) -> 시험 -> 유지보수 과정을 거침

프로토타입 모형(Prototype Model)
: 요구사항을 정확히 파악하기 위해 실제 개발될 소프트웨어에 대한 시제품을 만들어
  최종 결과물을 예측하는 모형
	- 소프트웨어 개발이 완료된 시점에서 오류가 발견되는 폭포수 모델의 단점을 보완하기 위해 만들어진 모형
	- 사용자와 시스템 사이 인터페이스에 중점을 두어 개발

나선형 모형(Spiral Model)
: 폭포수 모형과 프로토타입 모형의 장점에 위험 분석 기능을 추가한 모형
	- 나선을 따라 돌듯 여러 번의 개발 과정을 거쳐 점진적으로 완벽한 최종 소프트웨어를 개발
	- 소프트웨어를 개발하면서 발생할 수 있는 위험을 관리하고 최소화하는 것이 목적
	- 누락되거나 추가된 요구사항을 첨가할 수 있음
	- 정밀하고 유지보수 과정이 필요 없음
	- 대규모 프로젝트에서 많이 쓰임
		1. 목표설정(Determine Objective)
		2. 위험 분석(Risk Analysis)
		3. 개발과 검증(Development and Test)
		4. 고객평가/다음단계수립(Evaluation/Plan the next Iteration)

애자일 모형(Agile Model)
: 고객의 요구사항 변화에 유연하게 대응할 수 있도록 일정한 주기를 반복하면서 진행하는 모형
	- 좋은 것을 빠르고 낭비 없게 만들기 위해 고객과의 소통에 초점을 맞춘
	  모든 방법론을 통칭
	- 스프린트 또는 이터레이션이라고 불리는 짧은 개발 주기를 반복
	- 반복되는 주기마다 결과물에 대해 평가와 요구 수용
	- 요구사항에 우선순위를 부여하여 개발 진행
	- 애자일 모형을 기반으로 하는 모형에는 스크럼, XP, 칸반, Lean,
	  크리스탈, ASD, FDD, DSDM 등이 있음
		※ 애자일은 개발 방법론이 아니며, 특정 프로그램을 빠르고 낭비 없게
		   만들기 위해 고객과의 소통에 초점을 맞춘 모든 개발론을 통칭함

스크럼(Scrum)
: 럭비용어에서 파생된 언어로 여럿이 똘똘 뭉쳐 힘을 쓰는 것처럼 팀끼리 협업하면서 개발하는 것을 말함
	- 애자일의 여러 가지 실천 도구 중 하나
	- 팀이 중심이 되어 개발의 효율성을 높임
	- 팀원 스스로가 팀을 구성하고 개발 작업에 대한 모든 것을 스스로 해결할 수 있어야 함

스크럼의 구성 요소
	ㄱ. 제품 책임자
	: 개발될 제품에 대한 이해도가 높고 요구사항을 책임지고 의사 결정을 할 사람
		- 개발 의뢰자나 사용자가 담당
		- 이해관계자들의 의견을 종합하여 제품에 대한 요구사항을 작성
		- 백로그를 작성
		- 팀원들은 백로그에 스토리는 추가할 수 있지만 우선순위를 지정하는 것은 제품 책임자임
		- 테스트를 수행하면서 주기적으로 요구사항의 우선순위 갱신
	ㄴ. 스크럼 마스터
	: 팀이 잘 수행할 수 있도록 객관적인 시각에서 조언을 해주는 가이드 역할
		- 일일 스크럼 회의를 주관하여 진행 사항을 점검하고 개발과정에서
		  발생된 장애 요소를 공론화하여 처리함
	ㄷ. 개발팀
	: 개발자 외에도 디자이너, 테스터 등 제품 개발을 위해 참여하는 모든 사람을 지칭
		- 보통 최대 인원은 7~8명이 적당함
	ㄹ. 제품 백로그
	: 개발에 필요한 요구사항을 우선순위에 따라 나열한 목록
		- 작성된 사용자 스토리를 기반으로 릴리즈 계획을 수립
	ㅁ. 스프린트 계획 회의
	: 이번 스프린트에서 수행할 작업을 대상으로 단기 일정 수립
		- 처리할 요구사항을 개발자들이 나눠서 작업할 수 있도록 태스크라는
		  작업 단위로 나눠 개발자 별로 수행할 작업 목록인 스프린트 백로그(Sprint Backlog) 작성
	ㅂ. 스프린트
	: 실제 개발 작업을 진행하는 과정
		- 스프린트 백로그에 작성된 태스크를 대상으로 작업 시간이나 양을 추정한 후 개발 담당자에게 할당
		- 태스크를 할당할 때는 개발자가 원하는 태스크를 직접 선별하여 담당할 수 있도록 하는것이 좋음
		- 할당된 태스크는 할 일, 진행 중, 완료의 상태를 가짐
	ㅅ. 일일 스크럼 회의
	: 모든 팀원이 매일 약속된 시간에 짧은 시간동안 진행 상활을 점검하는 회의
		- 스크럼 마스터는 발견된 장애 요소를 해결할 수 있도록 도와줌
		- 남은 작업 시간은 소멸 차트에 표시
	ㅇ. 스프린트 검토 회의(Sprint Review)
	: 부분 또는 완성 제품이 요구사항에 잘 부합되는지 사용자가 포함된 참석자 앞에서 테스트를 수행
	ㅈ. 스프린트 회고(Sprint Retrospective)
	: 스프린트가 끝나고 정해놓은 규칙을 잘 준수했는지, 개선할 점은 없는지 등을 점검하고 수행

XP(eXtreme Programming)
: 수시로 발생하는 고객의 요구사항에 유연하게 대응하기 위해 고객의 참여와 개발 과정의 반복을
  극대화하여 개발 생산성을 향상시키는 기법
	- 짧고 반복적인 개발주기, 단순한 설계, 고객의 적극적인 참여를 통해 빠르게 개발하는 것이 목적
	- 릴리즈의 기간을 짧게 반복하면서 요구사항 반영에 대한 가시성을 높임
	- XP의 5가지 핵심 가치 : 의사소통, 단순성, 용기, 존중, 피드백

XP 개발 프로세스
	ㄱ. 사용자 스토리
	: 고객의 요구사항을 간단한 시나리오로 표현한 것
	ㄴ. 릴리즈 계획 수립
	: 몇 개의 스토리가 적용되어 부분적으로 기능이 완료된 제품을 제공하는 것에 대한 계획 수립
	(release의 사전적 의미는 "풀어 주다", "석방하다", 놓아 주다" 로서
	 여기서의 의미는 "배포" 정도로 생각하면 됨)
	ㄷ. 스파이크
	: 요구사항의 신뢰성을 높이고 기술 문제에 대한 위험을 감소시키기 위해 별도로 만드는 프로그램
	ㄹ. 이터레이션(Iteration)
	: 하나의 릴리즈를 더 세분화 한 단위
	(Iteration의 사전적 의미는 '반복')
	ㅁ. 승인 검사
	: 하나의 이터레이션 안에서 계획된 릴리즈 단위의 부분 완료 제품이 구현되면 수행하는 테스트
		- 사용자 스토리 작성 시 함께 기재한 테스트 사항에 대해 고객이 직접 수행
	ㅂ. 소규모 릴리즈
	: 고객의 반응을 기능별로 확인하고 고객의 요구사항에 유연하게 대응하는 것
		- 진행된 이터레이션이 모두 완료되면 고객에 의한 최종 테스트 수행 후
		  최종 결과물을 고객에게 전달함

XP의 주요 실천 방법
	ㄱ. Pair Programming
	: 다른 사람과 함께 프로그래밍 수행
	ㄴ. Test-Driven Development
	: 실제 코드 작성 전 테스트 케이스를 먼저 작성하여 무엇을 해야할지 파악 후 개발
	ㄷ. Whole Team
	: 개발에 참여하는 모든 구성원은 각기 역할이 있어 책임을 다해야 함
	ㄹ. Continuous integration
	: 모듈 단위로 나눠 개발한 코드는 하나의 작업이 마무리되면 지속적으로 통합
	ㅁ. Design Improvement / Refactoring
	: 프로그램 기능의 변경 없이 시스템을 재구성
	ㅂ. Small Release
	: 릴리즈 기간을 짧게 하여 고객의 요구 변화에 신속하게 대응


현행 시스템 파악 절차
: 새로 개발하려는 시스템의 개발 범위를 명확이 설정하기 위해 현행 시스템의 구성, 제공 기능,
  사용되는 기술, 네트워크 등의 기존 시스템에 대한 분석을 말함
	ㄱ. 1단계
		a. 시스템 구성 파악
		: 조직의 업무를 담당하는 기간 업무와 이를 지원하는 업무로 구분하여 나타낸 구성을 파악
		b. 시스템 기능 파악
		: 현재 제공하는 기능들을 주요, 하부, 세부 기능으로 구분하여 계층형으로 표시
		c. 시스템 인터페이스 파악
		: 주고받는 데이터의 종류, 형식, 프로토콜, 연계 유형, 주기 등을 명시
	ㄴ. 2단계
		a. 아키텍쳐 구성 파악
		: 어떠한 기술 요소들이 사용되는지 최상위 수준에서 계층별로 표현한 구성 파악
		b. 소프트웨어 구성 파악
		: 업무 처리를 위해 설치되어 있는 소프트웨어의 제품명, 용도, 라이선스 적용 방식 등을 명시
	ㄷ. 3단계
		a. 하드웨어 구성 파악
		: 단위 업무 시스템들이 운용되는 서버의 주요 사양과 수량 및 이중화 적용 여부 명시
		b. 네트워크 구성 파악
		: 서버의 위치, 서버 간의 네트워크 연결 방식을 네트워크 구성도로 작성


개발 기술 환경 파악

개발 기술 환경
: 개발하고자 하는 소프트웨어와 관련된 O/S, DBMS, Middle Ware 등을 선정할 때 고려해야 할 사항을 기술하고
		오픈 소스 사용 시 주의해야 할 내용을 제시

운영체제(Operating System)
: 컴퓨터 시스템 자원을 효율적으로 관리하여 사용자가 컴퓨터를 편리하게 사용할 수 있도록 환경을 제공하는 소프트웨어
	- 요구사항 식별 시 고려사항 : 가용성, 성능, 기술 지원, 주변 기기, 구축비용
	- Window, Unix, Linux 등이 있음

데이터 베이스 관리 시스템(DBMS)
: 사용자와 데이터베이스 사이에서 사용자의 요구에 따라 정보를 생성해주고 관리해주는 소프트웨어
	- 요구사항 식별 시 고려사항 : 가용성, 성능, 기술 지원, 상호 호환성, 구축비용

웹 애플리케이션 서버(WAS)
: 사용자의 요구에 따라 변하는 동적인 컨텐츠를 처리하기 위해 사용되는 미들웨어
	- 요구사항 식별 시 고려사항 : 가용성, 성능, 기술 지원, 구축비용
	(미들웨어 : 컴퓨터 제작 회사가 사용자의 요구대로 만들어 제공하는 프로그램으로,
	 운영체제와 응용 소프트웨어의 중간에서 조정과 중개의 역할을 수행하는 소프트웨어)

오픈 소스(Open Source)
: 누구나 제한 없이 사용할 수 있도록 소스 코드를 공개한 것
	- 오픈 소스 사용 시 고려해야할 사항 : 라이선스의 종류, 사용자의 수, 기술의 지속 가능성


요구사항 정의

요구사항
: 소프트웨어가 어떤 문제를 해결하기 위해 제공하는 서비스에 대한 설명과
  정상적으로 운영되는데 필요한 제약조건 등
	- 요구사항이 제대로 정의되어야 이를 토대로 이후 과정의 목표와 계획의 수립이 가능

요구사항의 유형
	ㄱ. 기능적 요구사항
	: 시스템이 무엇을 하고 어떤 기능을 하는지에 대한 사항
	ㄴ. 비기능적 요구사항
	: 성능, 장비구성 등 품질이나 제약사항에 대한 사항
	ㄷ. 사용자 요구사항
	: 사용자의 관점에서 본 시스템이 제공해야 할 사항
	ㄹ. 시스템 요구사항
	: 개발자의 관점에서 본 시스템 전체가 사용자와 다른 시스템에 제공해야 할 사항

요구사항 개발 프로세스
: 요구사항을 체계적으로 도출하고 이를 분석한 후 분석 결과를 명세서에 정리한 후
  이를 확인 및 검증하는 구조화된 활동
	- [도출 -> 분석 -> 명세 -> 확인]의 순서로 이루어짐
		ㄱ. 요구사항 도출
		: 요구사항이 어디에 있고 어떻게 수집할지 식별하고 이해하는 과정으로
		  인터뷰, 설문, 브레인스토밍, 워크샵, 프로토타이핑, 유스케이스 등이 있음
			a. 브레인스토밍
			: 3인 이상이 자유롭게 아이디어를 산출해 내는 방법
			b. 워크샵
			: 소집단 정도의 인원으로 특정 문제나 과제에 대한 새로운 지식, 기술,
			  아이디어, 방법들을 서로 교환하고 검토하는 연구회 및 세미나
			c. 프로토타이핑
			: 초기 도출된 요구사항을 토대로 프로토타입을 만든 후 개발이 진행되는 동안
			  도출되는 요구사항을 반영하면서 지속적으로 프로토타입을 재작성하는 과정
			d. 유스케이스
			: 사용자 측면에서의 요구사항으로 사용자가 원하는 목표를 달성하기 위해
			  사용자 요구사항을 기능 단위로 정리한 시나리오
		ㄴ. 요구사항 분석
		: 개발의 실질적 첫 단계로, 개발 대상에 대한 사용자의 요구사항을 이해하고
		  문서화(명세화)하는 과정을 의미
			- 사용자 요구사항의 타당성 조사, 비용과 일정에 대한 제약 설정
			- 도출된 요구사항 토대로 소프트웨어 범위 파악
			- 자료 흐름도(Data Flow Digram), 자료 사전(Data Dictionary) 등의 도구가 사용
				a. 자료 흐름도
				: 요구사항 분석에서 자료의 흐름 및 변환 과정과 기능을 도형 중심으로 기술하는 방법
				(표기법을 두 가지로 분류할 수 있으나 여기서는 자주 출제되는 Youdon/DeMacro 표기법만 표기
				 그 외 표기법으로는 Gane/Sarson 표기법이 있는데 사실상 거의 안나온다.)
				기호		의미
				프로세스		- 자료를 변환시키는 시스템의 한 부분을 나타내며
				(Process)		  원이나 둥근 사각형으로 표기
						- 원 안에 프로세스 이름 기입

				자료 흐름		- 자료의 이동이나 연관관계를 의미
				(Data Flow)	- 화살표 위에 자료 이름 기입

				자료 저장소	- 시스템에서의 자료 저장소 의미
				(Data Store)	- 도형 안에 저장소 이름 기입

				단말		- 시스템과 교신하는 외부 개체로
				(Terminator)	  입력 데이터가 만들어지고 출력 데이터를 받음
						- 도형 안에 이름 기입
				b. 자료 사전
				: 자료 흐름도에 있는 자료를 더 자세히 정의하고 기록한 것으로,
				  이렇게 데이터를 설명하는 데이터를 메타 데이터(Meta Data)라고 함
					- 자료 사전에 사용되는 표기 기호는 아래의 표와 같음
				기호		의미
				=		자료의 정의 : ~은 ~로 구성되어 있다는 의미
				+		자료의 연결 : 그리고(And)의 의미
				(  )		자료의 생략 : 생략이 가능한 자료
				[ | ]		자료의 선택 : 또는(Or)의 의미
				{   }		자료의 반복 : 자료의 반복을 의미
				*   *		자료의 설명 : 주석을 의미
		ㄷ. 요구사항 명세
		: 요구사항을 분석한 후 승인될 수 있도록 문서화하는 과정
			- 요구사항은 빠짐없이 완전하고 명확하게 기술 되어야 함
			- 사용자가 이해하기 쉬우며, 개발자가 효과적으로 설계할 수 있게 작성되어야 함
			- 설계 과정에서 잘못된 부분이 확인될 경우 그 내용을 요구사항 정의서에서
			  추적할 수 있어야 함
		ㄹ. 요구사항 확인
		: 문서화된 요구사항을 훑어보면서 확인하는 과정
			- 시스템 정의서, 시스템 사양서, 소프트웨어 요구사항 명세서 등을 완성한 시점에 이루어짐


요구사항 분석 CASE와 HIPO

요구사항 분석을 위한 CASE(Computer Aided Software Engineering)::자동화 도구
: 요구사항을 자동으로 분석하고, 요구사항 분석 명세서를 기술하도록 개발된 도구
	- 표준화와 보고를 통한 문서의 품질 개선
	- 명세에 대한 유지보수 비용 축소
	- 요구사항 변경이 주는 영향 추적 용이

CASE의 종류 ::SADT, SREM, PSL/PSA 등이 있음
	ㄱ. SADT(Structure Analysis and Design Technique)
	: SoftTech 사에서 개발한 것으로 구조적 요구 분석을 하기 위해
	  블록 다이어그램을 채택한 자동화 도구
	ㄴ. SREM(Software Requirements Engineering Methodology)
	: TRW 사가 우주 국방 시스템 그룹에 의해 실시간 처리 소프트웨어 시스템에서
	  요구사항을 명확히 기술하도록 할 목적으로 개발한 자동화 도구로 RSL(요구사항 기술 언어)와
	  REVS(요구사항 명세서 출력 및 요구사항 분석기)를 사용
	ㄷ. PSL/PSA
	: 미시간 대학에서 개발한 자동화 도구
		a. PSL(Problem Statement Language) : 요구사항 기술 언어
		b. PSA(Problem Statement Analyzer) : PSL로 기술한 요구사항 분석 후 보고서를 출력하는 분석기

HIPO(Hierarchy Input Process Output)
: 시스템의 분석/설계, 문서화 시 사용하는 기법으로 시스템의 입력, 처리, 출력 기능을 나타냄
	- 기본 시스템 모델은 입력, 처리, 출력으로 구성되며,
	  하향식 소프트웨어 개발을 위한 문서화 도구
	- 체계적인 문서 관리 가능
	- 기호, 도표 등을 사용하므로 보기 쉽고 이해하기 쉬움
	- 기능과 자료의 의존 관계 동시에 표현 가능

HIPO 차트의 종류
	ㄱ. 가시적 도표(Visual Table of Contents) ::목차
	: 시스템의 전체적인 기능과 흐름을 보여주는 계층 구조
	ㄴ. 총체적 도표(Overview Diagram) ::개요
	: 프로그램을 구성하는 기능을 기술한 것으로 입력/처리/출력에 대한 전반적 정보 제공
	ㄷ. 세부적 도표(Detail Diagram) ::상세 도표
	: 총체적 도표에 표시된 기능을 구성하는 기본 요소들을 상세히 기술하는 도표

UML(Unified Modeling Language)
: 시스템 개발 과정에서 시스템 개발자와 고객 또는 개발자 상호 간의 의사소통이 원활하게 이루어지도록
  표준화한 객체지향 모델링 언어(한 마디로 개발자와 클라이언트(::고객)간에 의사소통 시 표준화된 단어나
  언어가 없으면 같은 대상물도 다르게 표현하는 경우가 있는데, 이런 것들을 방지하기 위하여 표준화한 언어)
	- 객체지향 방법론의 장점을 통합하였으며 OMG(Object Management Group)에서 표준으로 지정

UML 구성 요소
: 사물(Things), 관계(Relationships), 다이어그램(Diagram)
	ㄱ. 사물
	: 모델을 구성하는 가장 중요한 기본 요소
		- 다이어그램 안에서 관계가 형성될 수 있는 대상
			a. 구조 사물
			: 시스템의 개념적, 물리적 요소 표현
				- 클래스, 유스케이스, 컴포넌트, 노드 등
			b. 행동 사물
			: 시간과 공간에 따른 요소들의 행위 표현
				- 상호작용, 상태 머신 등
			c. 그룹 사물
			: 요소들의 그룹으로 묶어서 표현
				- 패키지(그룹화)
			d. 주해 사물
			: 부가적인 설명이나 제약조건 등 표현
				- 부가 설명
	ㄴ. 관계
	: 사물과 사물 사이의 연관성 표현
		a. 연관 관계
		: 2개 이상의 사물이 서로 관련되어 있음을 표현
			- 실선과 화살표로 연결하여 표현하지만 양방향 관계의 경우
			  화살표 없이 실선으로 연결하여 표현
			다중도		의미
			1		1개의 객체가 연관됨
			n		n개의 객체가 연관됨
			0..1		연관된 객체가 없거나 1개만 존재
			0..* / *		연관된 객체가 없거나 다수일 수 있음
			1..*		연관된 객체가 적어도 1개 이상
			n..*		연관된 객체가 적어도 n개 이상
			n..m		연관된 객체가 n~m개
			          1		    1
			ex) 사람---------------->빵
			[의미 해석]
			- 사람은 빵을 소유하는 관계. 사람은 자기가 소유하고 있는 빵이 무엇인지 알고,
			  빵은 어느 사람이 자신을 소유하고 있는지 모른다(화살표 방향이 한 방향)
			- '사람'쪽에 표기된 다중도가 '1'이므로, 빵은 한 사람에 의해서만 소유될 수 있다.
			- '빵'쪽에 표기된 다중도가 '1'이므로 사람은 하나의 빵만을 소유할 수 있다.
		b. 집합 관계
		: 하나의 사물이 다른 사물에 포함되어 있는 관계
			- 부분(포함되는 쪽)에서 전체(포함하는 쪽)로 속이 빈 마름모를 연결하여 표현

			ex) 컴퓨터◇-----------프린터
			[의미 해석]
			- 프린터는 컴퓨터에 연결해서 사용할 수 있으며, 다른 컴퓨터에 연결해서 사용할 수도 있다.
		c. 포함 관계
		: 집합 관계의 특수한 형태로 포함하는 사물의 변화가 포함되는 사물에게 영향을 미치는 관계
			- 부분(포함되는 쪽)에서 전체(포함하는 쪽)로 속이 채워진 마름모를 연결하여 표현

			ex) 문◆-----------------키
			[의미 해석]
			- 문을 열 수 있는 키는 하나이며, 해당 키로 다른 문을 열 수 없다.
			  문이 없어지면 키도 더이상 필요하지 않다.
		d. 의존 관계
		: 사물 사이에 연관은 있으나 필요에 의해서 서로에게 영향을 주는 짧은 시간 동안만 연관을 유지하는 관계
			- 영향을 주는 사물이 영향을 받는 사물쪽으로 점선 화살표 연결

			ex) 회원등급- - - - - - - - ->할인율
			[의미 해석]
			- 회원등급이 높으면 할인율을 적용, 회원등급이 낮으면 할인율을 미적용 한다.
		e. 일반화 관계
		: 하나의 사물이 다른 사물에 비해 일반적인지 구체적인지 표현
			- 구체적인 사물에서 일반적인 사물 쪽으로 속이 빈 화살표를 연결

			ex)	---------▷커피◁--------
			   아메리카노		카페라떼
			[의미 해석]
			- 아메리카노와 카페라떼는 커피이다(커피의 종류로는 아메리카노와 카페라떼가 있다)
		f. 실체화 관계
		: 사물이 할 수 있거나 해야 하는 기능으로 서로를 그룹화 할 수 있는 관계
			- 사물에서 기능 쪽으로 속이 빈 점선 화살표 연결

			ex)   - - - - -▷날수있는◁- - - - -
			    새			비행기
			[의미 해석]
			- 비행기와 새는 날 수 있다.
			  (난다는 행위 자체로 그룹화 할 수 있다, 일반화 관계와는 다르게 사물이 할 수 있는 기능에 초점)


다이어그램
: 사물과의 관계를 도형으로 표현
	- 정적 모델링에서는 주로 구조적 다이어그램을 사용,
	  동적 모델링에서는 주로 행위 다이어그램을 사용
	- 아래 해당하는 구조/행위 다이어그램에 대해 암기 필수
		ㄱ. 구조적 다이어그램
		: 특정한 구조와 틀을 다이어그램으로 제작
			a. 클래스 다이어그램
			: 클래스, 클래스가 가지는 속성, 클래스 사이 관계 표현
			b. 객체 다이어그램
			: 인스턴스를 특정 시점의 객체와 객체 사이의 관계로 표현
			*인스턴스
			: 실행 중인 임의의 프로세스, 클래스의 현재 생성된 오브젝트를 의미
			c. 컴포넌트 다이어그램
			: 구현 단계에서 사용되며 실제 구현 모듈인 컴포넌트 간의 관계나 인터페이스를 표현
			*컴포넌트
			: 프로그래밍에 있어서 독립적인 업무 또는 독립적인 기능을 수행하는 모듈로서
			  시스템을 유지보수 하는데 있어 교체 가능한 부품을 말함
			*모듈
			: 프로그래밍적 관점으로 봤을 시 프로그램을 구성하는 구성 요소의 일부분으로 독립된 하위 단위
			  (예를 들면 A+B+C = 상품 이 있다고 가정했을 시 상품의 하위에 해당하는 A, B, C가 모듈이라고 할 수 있음)
			d. 배치 다이어그램
			: 구현단계에서 사용되며 결과물, 프로세스, 컴포넌트 등 물리적 요소들의 위치 표현
			e. 복합체 구조 다이어그램
			: 복잡한 구조를 가지는 클래스 혹은 컴포넌트의 내부 구조 표현
			f. 패키지 다이어그램
			: 유스케이스, 클래스 등의 모델 요소들을 그룹화한 패키지들의 관계 표현
			*클래스
			: 객체지향에서 클래스란 객체를 정의하는 틀 또는 설계도와 같은 의미로 사용
			*객체
			: 컴퓨터 과학에서 객체 또는 오브젝트(Object)는 클래스에서 정의한 것을 토대로
			  메모리(실제 저장 공간)에 할당된 것으로 프로그램에서 사용되는 데이터 또는
			  식별자에 의해 참조되는 공간을 의미하며 물리적으로 존재하거나 추상적으로
			  생각할 수 있는 것 중 자신의 속성을 가지고 있고 다른 것과 식별 가능한 것들을 말한다.
		ㄴ. 행위 다이어그램
		: 특정한 행위나 동작을 다이어그램으로 제작
			a. 유스케이스 다이어그램
			: 사용자의 요구를 분석하여 기능 모델링 작업에 사용됨
			*유스케이스(Use Case)
			: 사용자 측면에서의 요구사항으로 사용자가 원하는 목표를 달성하기 위해 수행할 내용 기술
			b. 시퀀스 다이어그램
			: 상호 작용하는 시스템이나 객체들이 주고받는 메시지 표현
			c. 커뮤니케이션 다이어그램
			: 객체들이 주고받는 메시지를 표현할 뿐 아니라 객체들 간의 연관까지 표현
			d. 상태 다이어그램
			: 하나의 객체가 자신이 속한 클래스의 상태 변화 혹은 다른 객체와의 상호 작용에 따라
			  어떻게 변화하는지 표현
			e. 활동 다이어그램
			: 객체의 처리 로직이나 조건에 따른 처리의 흐름을 순서에 따라 표현
			f. 상호작용 개요 다이어그램
			: 상호작용 다이어그램 간의 제어 흐름 표현
			g. 타이밍 다이어그램
			: 객체 상태 변화와 시간 제약을 명시적으로 표현


스테레오 타입(Stereotype)
: UML에서 표현하는 기본 기능 외에 추가적인 기능을 표현하기 위해 사용
	- ( << >> ) 겹화살괄호 사이에 표현할 형태를 기술
	기호		의미
	<<include>>	연결된 다른 UML 요소에 대해 포함 관계
	<<extend>>	연결된 다른 UML 요소에 대해 확장 관계
	<<interface>>	인터페이스 정의
	<<exception>>	예외 정의
	<<constructor>>	생성자 역할을 수행하는 경우

주요 UML 다이어그램
: 자주 출제되는 UML 다이어그램 정리

	ㄱ. 유스케이스(Use Case) 다이어그램
	: 다른 외부 시스템들이, 개발될 시스템을 이용하여 수행할 수 있는 기능을
	  사용자의 관점에서 다이어그램으로 작성

		        ------제품목록을 본다.<---<<include>>---제품을 삭제한다.
		사용자------바코드를 스캔한다.<---<<include>>---제품을 등록한다.<---<<extend>>---파일을 첨부한다. 
		        ------알람을 설정한다.<---<<include>>---알람을 수정한다.

		-유스케이스 다이어그램은 시스템 범위, 액터, 유스케이스, 관계로 구성됨
		a. 시스템 범위(System Scope)
		: 시스템 내부에서 수행되는 기능들을 외부 시스템과 구분하기 위해 시스템 내부의 유스케이스들을
		  사각형으로 묶어 시스템의 범위 표현
		b. 액터(Actor)
		: 시스템과 상호작용을 하는 모든 외부 요소로, 사람이나 외부 시스템을 의미함
		c. 유스케이스(Use Case)
		: 사용자가 보는 관점에서 시스템이 액터에게 제공하는 서비스 또는 기능을 표현한 것
		d. 관계(Relationship)
		: 유스케이스 다이어그램에서 관계는 액터와 유스케이스, 유스케이스와 유스케이스간 나타날 수 있으며
		  포함 관계, 확장 관계, 일반화 관계의 종류가 있음
	ㄴ. 클래스(Class) 다이어그램
	: 시스템을 구성하는 클래스, 클래스의 특성인 속성과 오퍼레이션, 클래스 사이의 관계를 다이어그램으로 작성
		- 시스템 구성 요소에 대한 이해가 가능
		- 코딩에 필요한 객체 속성, 함수 등의 정보를 잘 표현하고 있어 시스템 모델링에 자주 사용
		- 클래스 다이어그램은 클래스, 제약조건, 관계 등으로 구성
	ㄷ. 시퀀스 다이어그램(Sequence)
	: 시스템이나 객체들이 메시지를 주고받으며 시간의 흐름에 따라 상호 작용하는 과정을
	  액터, 객체, 메시지 등의 요소를 사용하여 다이어그램으로 작성
		- 시스템과 객체들의 상호 작용 과정에서 주고 받는 메시지 표현
		- 각 동작에 참여하는 시스템이나 객체들의 수행 기간 확인 가능
		- 클래스 내부에 있는 객체들을 기본 단위로 하여 그들의 상호 작용을 표현
		- 시퀀스 다이어그램은 주로 기능 모델링에서 작성한 유스케이스 명세서를 하나의 표현 범위로 하지만,
		  하나의 클래스에 포함된 오퍼레이션을 하나의 범위로 표현하기도 함
		  *오퍼레이션
		  : 객체지향 프로그래밍에서 오퍼레이션이란 '객체의 기능' 정도로 정의할 수 있음
		- 아래는 시퀀스 다이어그램 구성 요소 표
		구성 요소		의미
		액터		시스템으로부터 서비스를 요청하는 외부 요소로
				사람이나 외부 시스템을 의미

		객체		메시지를 주고받는 객체를 의미

		생명선		객체가 메모리에 존재하는 기간을 의미하며,
				객체 아래쪽에 점선을 그어 표시

		실행 상자		객체가 메시지를 주고받으며 구동되고 있음을 표현

		메시지		객체가 상호 작용을 위해 주고받는 메시지를 표현


사용자 인터페이스(User Interface)
: 사용자와 시스템 간의 상호작용을 원활하게 도와주는 장치나 소프트웨어
  (흔히들 현업에 가면 현업자분들이 UI, UX거리는데 사용자 사용 환경, 디자인 등을 말한다고 생각하면 됨)

사용자 인터페이스의 3가지 분야
	- 정보 제공과 전달을 위한 물리적 제어에 관한 분야
	- 콘텐츠의 상세적인 표현과 전체적인 구성에 관한 분야
	- 모든 사용자가 편리하고 간편하게 사용하도록 하는 기능에 관한 분야

사용자 인터페이스의 구분
	ㄱ. CLI(Command Line Interface)
	: 명령과 출력이 텍스트 형태로 이루어지는 인터페이스

	ex)
	linux : /etc/apache2/conf.d $ pwd
	/etc/apache2/conf.d
	linux : /etc/apache2/conf.d $ cd ~
	linux : ~ $ pwd
	/home/ubuntu
	linux : ~ $ cd -
	/etc/apache2/conf.d
	linux : /etc/apache2/conf.d $ pwd
	/etc/apache2/conf.d
	linux : /etc/apache2/conf.d $

		- 리눅스 같은 검은 화면에 명령어를 입력하고 결과값을 텍스트로 받는
		  모든 형태를 말함
	ㄴ. GUI(Graphic User Interface)
	: 아이콘이나 메뉴를 마우스로 선택하여 작업을 수행하는 인터페이스
		- 대표적인게 우리가 많이 사용하는 Window 환경!
	ㄷ. NUI(Natural User Interface)
	: 말이나 행동으로 조작하는 인터페이스
		- 손짓으로 넘기는 모션 인식이나 언어로 조작하는 삼성의 빅스비 등을 생각하면 됨

사용자 인터페이스의 기본 원칙
	ㄱ. 직관성
	: 사용자가 큰 노력 없이 쉽게 이해하고 사용할 수 있게 제작해야 함
	  (= 쉽게 직관적으로 배울 수 있어야 함)
	ㄴ. 유효성
	: 사용자의 목표가 쉽게 달성될 수 있도록 제작 되어야 함
	  (= 사용자가 원하는 행동을 쉽게 진행할 수 있어야 함)
	ㄷ. 학습성
	: 초보자가 쉽게 배우고 사용할 수 있게 제작되어야 함
	ㄹ. 유연성
	: 사용자의 인터랙션을 최대한 포용하고 실수를 방지할 수 있게 제작 되어야 함
	  (= 사용자와 사용되는 프로그램이나 기기간의 상호작용을 최대한 포용할 수 있어야 함)

사용자 인터페이스의 설계 지침
: 사용자 중심, 일관성, 단순성, 결과 예측 가능, 가시성, 표준화, 접근성, 명확성, 오류 발생 해결
	- 단순히 읽은 의미 그대로 받아들이면 됨, 너무 깊게 생각하지 말 것, 내가 개발자라고 생각했을 시
	  사용자의 편의성을 어떻게 고려해 줄 것인가에 대한 표준 가이드라고 생각하면 됨


UI표준 및 지침
: UI 표준과 지침을 토대로 기술의 중립성(표준), 보평적 표현 보장성(접근성),
  기능의 호환성이 고려되었는지 확인

한국형 웹 콘텐츠 접근성 지침(KWCAG-Korean Web Content Accessibility Guidelines)
: 장애인과 비장애인이 동등하게 접근할 수 있는 웹 콘텐츠 제작의 방법 제시
	- 웹 콘텐츠 접근성 지침 준수를 위한 고려사항임

전자정보 웹 표준 준수 지침
: 정부기관의 홈페이지 구축 시 반영해야 할 최소한의 규약
	- 내용의 문법 준수
	- 내용과 표현의 분리
	- 동작의 기술 중립성 보장
	- 플러그인의 호환성
	- 콘텐츠의 보편적 표현
	- 운영체제에 독립적인 콘텐츠 제공
	- 부가 기능의 호환성 확보
	- 다양한 프로그램 제공
		: 어느 기업이 정부 기관 홈페이지 제작을 낙찰 받아 정부기관 홈페이지 구축 시,
		  위의 사항을 준수해야 함. 현업에서는 중요하지만 시험에서는 크게 중요하게 다뤄지지 않음.
		  시험에 나올 확률은 적으나 추후 홈페이지 개발자를 목표로 하시는 분들은
		  어느정도의 상식이니 기억해두면 좋습니다.

UI설계 도구
: 사용자의 요구사항에 맞게 UI를 설계할 때 사용하는 도구
	ㄱ. 와이어프레임(Wrieframe)
	: 기획 초기 단계에서 제작하는 것으로 페이지에 대한 대략적인 레이아웃이나
	  UI 요소 등에 대한 뼈대를 설계
		- 와이어프레임 툴 : 파워포인트, 키노트, 스케치, 일러스트, 포토샵 등
		  (손으로 그린 UI도 와이어프레임에 포함)
	ㄴ. 목업(Mockup)
	: 와이어프레임보다 좀 더 실제 화면과 유사하게 만드는 정적인 형태의 모형
		- 목업 툴 : 파워 목업, 발사믹 목업 등
		[설명] 현업에 간다면 결과물 디자인을 할 때 정말 많이 쓰며, 우스갯 소리로
		'디자인의 완성은 목업'이라는 말이 있습니다. 그정도로 목업 작업을 하면
		결과물이 흔히 한국인들이 좋아하는 있어 보이는 결과물이 잘 나옵니다.
	ㄷ. 스토리 보드(Stroy Board)
	: 와이어프레임에 콘텐츠에 대한 설명이나 페이지 간 이동 흐름 등을 추가한 문서
		- 디자이너와 개발자가 최종적으로 참고하는 작업 지침서
		- 서비스 구축을 위한 모든 정보가 담겨 있어야 함
		- 스토리보드 툴 : 파워포인트, 키노트, 스케치, Axure 등
		[설명] 한 마디로 정리하면 UI에서 어떤 버튼을 누를 시 뭐가 나온다는 식의 순서도와
		눌렀을 시의 기능 등이 전반적으로 담겨 있는 기능 등 모든 것을 포함한 최종 지침서 입니다.
	ㄹ. 프로토타입(Prototype)
	: 와이어프레임이나 스토리보드 등에 인터랙션을 적용해 실제 구현된 것처럼 테스트가 가능한
	  동적인 형태의 모형
		- 작성 방법에 따라 페이퍼/디지털 프로토타입으로 나눔
		- 프로토타입 툴 : HTML/CSS, Axure, Flinto, 네이버 프로토나우, 카카오 오븐 등
	ㅁ. 유스케이스(Use Case)
	: 사용자 측면에서의 요구사항으로 사용자가 원하는 목표를 달성하기 위해 수행할 내용 기술
	[설명] 유스케이스는 하나의 요구사항 달성을 위한 기법이라고 생각해야 합니다. 따라서 유스케이스는
	요구사항 도출, UI 설계 등 다양한 부분에서 사용 가능합니다. 유스케이스가 요구사항 도출에서 나오느냐
	UI설계에서 나오느냐 그런 것을 시험에서 물어보지 않습니다. '유스케이스란 무엇인가'에 초점을 맞춰서 학습

품질 요구사항
: 소프트웨어 품질은 소프트웨어의 기능, 성능, 만족도 등 소프트웨어에 대한 요구사항이 얼마나 충족하는가를 나타내는 지표
	ㄱ. 기능성(Functionality)
	: 사용자의 요구사항을 정확하게 만족하는 기능을 제공하는지 여부

		품질 요구사항		설명
		적합성/적절성		정해진 작업과 사용자 목적 달성을 위해
		(Suitability)		적절한 기능을 제공할 수 있는 능력

		정밀성/정확성		사용자가 요구하는 결과를 정밀하게
		(Accuracy)		산출할 수 있는 능력

		상호 운용성		다른 시스템과 상호간 어울려 작업할 수 있는
		(Interoperability)		능력

		준수성			표준 및 관련 규정을 준수할 수 있는 능력
		(Compliance)

		보안성			정보에 대한 접근을 사용자 권한에 따라
		(Security)			설정할 수 있는 능력

	ㄴ. 신뢰성 (::성숙성 | 고장 허용성 | 회복성 등이 있음)
	: 소프트웨어가 요구된 기능을 정확하고 일관되게 오류 없이 수행할 수 있는 정도
		a. 성숙성(Maturity)
		: 결함으로 인한 고장을 피할 수 있는 능력
		b. 고장 허용성(Fault Tolerance)
		: 결함 시에도 규정된 성능 수준을 유지할 수 있는 능력
		c. 회복성(Recoverability)
		: 고장 발생 시 규정된 성능 수준까지 회복하고 영향을 받았던 데이터를
		  복구할 수 있는 능력
	ㄷ. 사용성(Usability)
	: 컴퓨터와 사용자간의 인터랙션에 대해 사용자가 쉽게 배우고,
	  사용할 수 있으며 이후에도 계속 사용하고 싶은 정도를 나타냄

		품질 요구사항		설명
		이해성			소프트웨어의 사용 방법 등을 사용자가
					이해할 수 있는 능력

		학습성			소프트웨어를 학습할 수 있도록 하는
					능력

		친밀성			사용자가 소프트 웨어를 다시 사용하고
					싶어 하도록 하는 능력

		운용성			사용자가 소프트웨어를 운용 및 제어할 수
					있게 해주는 능력

	ㄹ. 효율성(Efficiency)
	: 사용자가 요구하는 기능을 할당된 시간 동안, 한정된 자원으로 얼마나 빨리
	  처리할 수 있는지 정도
	ㅁ. 유지 보수성(Maintainability)
	: 환경이 변화하거나 또는 새로운 요구사항이 발생했을 때 소프트웨어를 개선하거나
	  확장할 수 있는 정도
	ㅂ. 이식성(Portability)
	: 소프트웨어가 다른 환경에서도 얼마나 쉽게 적용할 수 있는지 정도


UI 요소
: UI를 구성하는 요소

	요소		설명
	체크 박스		여러개의 선택 상황에서 1개 이상의 값을 선택할 수 있는 버튼

	텍스트 박스	사용자가 데이터를 입력하고 수정할 수 있는 상자

	라디오 버튼	여러 항목중 하나만 선택할 수 있는 버튼

	콤보 상자		이미 지정된 목록 상자에 내용을 표시하여
			선택하거나 새로 입력 가능한 상자

	목록 상자		콤보 상자와 같이 목록을 표시하지만
			새로운 내용 입력 불가


소프트웨어 아키텍처(Software Archiecture)
: 소프트웨어의 골격이 되는 기본 구조, 혹은 소프트웨어를 구성하는
  요소들 간의 관계를 표현하는 시스템의 구조
[설명] 흔히들 건축에 소프트웨어 아키텍처를 비유를 많이 합니다.
건물도 짓기 전에, 뼈대를 잡고 어떠한 재료와 도구를 사용할 것인지
정하잖아요? 그걸 그대로 소프트웨어 제작에 반영한다고 생각하시면 됩니다.
	ㄱ. 상위 설계
	: 아키텍처 설계, 예비 설계라고 부르며 시스템의 전체적인 구조를 설계 함
	  (구조, DB, 인터페이스 등)
	ㄴ. 하위 설계
	: 모듈 설계, 상세 설계 라고 부르며 시스템의 내부 구조 및 행위에 관해 설계 함
	  (컴포넌트, 자료 구조, 알고리즘 등)

소프트웨어 아키텍처의 종류

모듈화
: 소프트웨어의 성능을 향상하거나 시스템의 수정 및 재사용, 유지 관리 등이 용이하도록
  시스템의 기능들을 모듈 단위로 나누는 것
	- 모듈의 크기와 개수는 반비례관계, 개수와 통합 비용은 비례 관계
	*모듈
	: 전체 프로그램 기능 중 특정 기능을 처리할 수 있는 소스 코드를 의미
	[설명] - 왜 모듈의 크기와 개수는 반비례관계, 개수와 통합비용은 비례관계일까?
	: 모듈을 제작하는데 들어가는 인력이 많기 때문입니다. 만약 회사에서 개발을 한다고 했을 시
	  모듈을 만들 때, 모듈에 대한 기획, 구성, 제작, 유기성 등을 고려하여 인력이 들어가기에
	  아무 생각 없이 코딩하는 것 보다 모듈을 만들 때 그만큼 인력이 많이 들어가므로
	  통합 비용은 올라갈 것입니다. 또한 모듈을 크게 만든다면 그 안에 많은 기능을 포함하고 있을테니
	  전체 제품에서 하나의 모듈이 차지하는 비중이 커지겠죠? 그렇기에 모듈이 커질수록 개수는
	  작아지는 것입니다. 실제 현장에서 모듈은 꼭 만들어야만 하는 것은 아니라 선택 사항입니다.
	  모듈화가 잘 되어 있을수록 유지보수성이 향상되지만 그만큼 최초 기획 및 제작에서 비용이 많이 들어가므로
	  적절한 인력과 적절한 모듈 개수를 잘 맞춰야 합니다.

추상화
: 문제의 전체를 설계 후 세분화하여 구체화하는 과정
	- 완전한 시스템을 구축하기 전에 그 시스템과 유사한 모델을 만들어
	  여러가지 요인들을 테스트할 수 있음
	- 최소 비용으로 실제 상황에 대처할 수 있고 시스템의 구조 및 구성을
	  대략적으로 파악할 수 있음
		ㄱ. 과정 추상화
		: 전반적인 흐름만 파악
		ㄴ. 데이터 추상화
		: 데이터의 세부사항은 정의하지 않고 구조를 대표할 수 있는 표현으로 대체
		ㄷ. 제어 추상화
		: 이벤트의 발생의 세부사항은 정의하지 않고 구조를 대표할 수 있는 표현으로 대체

단계적 분해
: 문제를 상위 중요 개념으로부터 하위의 개념으로 구체화하는 분할 기법
	- 추상화의 반복으로 세분화

정보 은닉
: 한 모듈 내부에 포함된 정보들을 감추어 다른 모듈이 접근하거나 변경하지 못하도록 하는 기법
	- 다른 모듈과 커뮤니케이션 할 때는 필요한 정보만 인터페이스를 통해 주고받음
	- 모듈을 독립적으로 수행하기 때문에 다른 모듈에 영향을 주지 않아
	  수정, 시험, 유지보수가 용이함

소프트웨어 아키텍처의 품질 속성
: 소프트웨어 아키텍처가 이해 관계자들이 요구하는 수준의 품질을 유지 및 보장할 수 있게 설계되었는지
  확인하기 위해 품질 평가 요소들을 시스템 측면, 비즈니스 측면, 아키텍처 측면으로 구분하여 구체화 시켜놓은 속성

소프트웨어 아키텍처의 설계 과정
설계 목표 설정		- 시스템의 개발 방향을 명확히 하기 위해 요구사항을 분석하여
			  전체 시스템의 설계 목표 설정
					↓
시스템 타입 결정		- 시스템과 서브 시스템 타입 결정
			- 설계목표를 고려하여 아키텍처 패턴 선택
					↓
아키텍처 패턴 적용		- 아키텍처 패턴을 참조하여 시스템의 표준 아키텍처 설계
					↓
서브시스템 구체화		- 서브시스템의 기능 및 상호작용을 위한 동작과 인터페이스 정의
					↓
결론			- 아키텍처가 설계 목표에 부합하는지, 요구사항이 잘 반영되었는지 등을 검토


아키텍처 패턴(Architecture Patterns)
: 아키텍처를 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제
	- 시스템의 구조를 구성하기 위한 기본적인 틀 제공
	- 서브시스템과 그 역할이 정의되어 있어 서브시스템 사이 관계와 규칙, 지침 등이 포함되어 있음

아키텍처 패턴의 장점
	- 개발 시간을 단축시킴
	- 고품질의 소프트웨어 생산 가능
	- 검증된 구조로 작업을 하여 안정적인 개발 가능
	- 시스템 구조를 이해하기 쉬워 개발에 참여하지 않아도 유지보수가 쉬움
		ㄱ. 레이어 패턴(Layer Pattern)
		: 시스템을 계층으로 구분하여 구성
			- 각각의 서브시스템이 계층 구조를 이룸
			- 상위 계층은 하위 계층에 대한 서비스 제공자가 되고
			  하위 계층은 상위 계층의 클라이언트가 됨
			- 마주 보는 두 계층 사이에만 상호 작용이 이루어짐
			- 특정 계층만을 교체해 시스템을 개선하는 것이 가능
			- 대표적인 레이어 패턴은 OSI 7Layer가 있음
			*OSI 7Layer
			: 국제 표준화기구(ISO)에서 개발한 모델로, 컴퓨터 네트워크 프로토콜 디자인과
			  통신을 계층으로 나누어 설명한 것.
		ㄴ. 클라이언트-서버 패턴(Client-Server Pattern)
		: 하나의 서버와 다수의 클라이언트 컴포넌트로 구성된 패턴
			- 사용자는 클라이언트를 통해 서버에 요청하고 응답을 받아 사용자에게 제공
			- 서버는 클라이언트의 요청에 대비해 항상 대기 상태 유지
			- 요청을 위하여 동기화되는 경우를 제외하고는 서로 독립적임
			*클라이언트
			: 컴퓨터 네트워크에서 클라이언트는 네트워크를 통하여 서버라는 다른 컴퓨터 시스템 상의
			  원격 서비스에 접속할 수 있는 응용 프로그램이나 서비스를 말함
					서버
				←	↓	→
			클라이언트	클라이언트	클라이언트
		ㄷ. 파이프-필터 패턴(Pipe-Filter Pattern)
		: 데이터 스트림 절차의 각 단계를 필터 컴포넌트로 캡슐화하여 파이프를 통해 데이터를 전송
			- 필터 컴포넌트는 재사용성이 좋고 추가가 쉬워 확장이 용이
			- 필터 컴포넌트를 재배치하여 다양한 파이프라인 구축 가능
			- 데이터 변환, 버퍼링, 동기화 등에 사용
			*데이터 스트림
			: 연결지향통신에서, 전송된 정보를 수집하거나 정보를 전송할 때 사용되는
			  디지털 방식으로 암호화 된 신호의 흐름

			[Source]---파이프1--->(필터1)---파이프2--->(필터2)---파이프3--->[Sink]

		ㄹ. 모델-뷰-컨트롤러 패턴(Model-View-Controller Pattern):: MVC패턴
		: 시스템을 아래의 3개의 부분으로 구조화하여 제작하여 각 부분은 별도로 분리되어 있어
		  서로 영향을 받지 않고 독립적인 개발 작업 수행 가능
			- 여러 개의 뷰를 만들 수 있어 한 개의 모델에 여러 개의 뷰를 필요로 하는
			  대화형 애플리케이션에 적합
			- 모델(Model) : 서브시스템의 핵심 기능과 데이터 보관
			- 뷰(View) : 사용자에게 보여주는 화면단
			- 컨트롤러(Controller) : 사용자로부터 받은 입력 처리(관제탑)

			[설명] MVC패턴은 현업에서도 정말 많이 사용하는 패턴입니다.
			특히나 국가에서 많이 사용하는 스프링 기반의 '전자정부프레임워크'라는 프레임워크에서
			많이 애용하는 방법으로, 대부분의 한국 신입 프로그래머들이 국가 SI기업에서 프로젝트를
			맡게 된다면 MVC패턴을 경험할 확률이 높을 것입니다.
			참고로 MVC패턴은 꼭 지켜야 한다는 것이기 보다는 SI특성상 사람들이 자주 나가고
			들어오고 하면서 담당자가 자주 바뀌는데 그럴 경우 시스템의 유지보수를 원활하게하기 위한
			방법 중 하나 입니다. 왜냐하면 코딩 패턴이 구조화&정형화 되어 있으면 다음 사람이 코드를
			보거나 분석할 때 훨씬 예측이 쉽기 때문에 편하고 빠르게 볼 수 있기 때문입니다.
			지옥도 SI로 간다면...이러한 디자인 패턴을 고려하지 않거나 있어도 지키지 않고 그냥
			'배 째^^ 난 시간만 맞추고 돈만 받고 갈거임' 같이 욕 나오게 코딩하는 사람들도 정말 많답니다.

기타 패턴
[설명] 기타 패턴 부분은 필기 준비 시 가볍게 읽고 넘기세요
	ㄱ. 마스터-슬레이브 패턴(Master-Slave Pattern)
	: 마스터 컴포넌트에서 슬레이브 컴포넌트로 작업을 분할한 후
	  슬레이브 컴포넌트에서 처리된 결과물을 다시 돌려받는 방식
	ㄴ. 브로커 패턴(Broker Pattern)
	: 사용자가 원하는 서비스와 특성을 브로커 컴포넌트에 요청하면
	  브로커 컴포넌트가 요청에 맞는 컴포넌트를 연결
	ㄷ. 피어-투-피어 패턴(Peer-To-Peer Pattern)
	: 피어를 하나의 컴포넌트로 간주하여 각 피어는 클라이언트 또는
	  서버가 될 수도 있음
	ㄹ. 이벤트-버스 패턴(Event-Bus Pattern)
	: 소스가 특정 채널에 이벤트 메시지를 발행하면 해당 채널을 구독한
	  리스너들이 메시지를 받아 이벤트를 처리하는 방식
	ㅁ. 블랙보드 패턴(Blackboard Pattern)
	: 모든 컴포넌트들이 공유 데이터 저장소와 블랙보드 컴포넌트에 접근이
	  가능하여 검색을 통해 블랙보드에서 원하는 데이터를 찾을 수 있음
	ㅂ. 인터프리터 패턴(Interpreter Pattern)
	: 프로그램 코드의 각 라인을 수행하는 방법을 지정하고
	  기호마다 클래스를 갖도록 구성

객체지향
: 현실 세계의 개체를 기계의 부품처럼 하나의 객체(Object)로 만들어
  소프트웨어를 개발할 때 조립하여 작성할 수 있는 기법
	- 구조적 기법의 문제점을 해결하기 위해 사용
	- 소프트웨어의 재사용 및 확장이 용이하여 고품질의 소프트웨어를
	  빠르게 개발할 수 있어 유지보수가 쉬움
	- 복잡한 구조를 단계적이고 계층적이게 표현
	- 멀티미디어 데이터 및 병렬 처리 지원
	- 구성 요소 : 객체, 클래스, 캡슐화, 상속, 다형성
	*객체
	: 물리적으로 존재하거나 추상적으로 생각할 수 있는 것 중 자신의 속성을
	  가지고 있고 다른 것과 식별 가능한 것

객체(Object)
: 바로 위에 있는 정의와는 조금 다르게 기출 문제에서는 객체를
  "실세계에 존재하거나 생각할 수 있는 것"으로 정의하였음
[설명] 사실 학부생 때 저도 저놈의 객체가 뭔지 정말 감을 못 잡았는데,
코딩을 계속 하다보면 아?... 이런 걸 말 하는거군? 하는 때가 온답니다...
다만 저희는 시험을 준비하는 입장이니 너무 깊게 들어가지 말고 딱
저 정도의 정의 정도만 알고 있으면 됩니다!
	ㄱ. 데이터
	: 객체가 가지고 있는 정보
	ㄴ. 함수
	: 하나의 특정한 목적의 작업을 수행하기 위해 독립적으로 설계된 코드의 집합

객체의 특성
	- 객체는 독립적으로 식별 가능한 이름을 가지고 있음
	- 객체의 상태는 시간에 따라 변함
	- 객체 간의 상호 연관성에 의해 관계 형성
	- 객체가 반응할 수 있는 메시지의 집합을 행위라고 하며
	  객체는 행위의 특징을 나타낼 수 있음
	- 객체는 일정한 기억 장소를 가지고 있음

클래스
: 객체 지향 프로그래밍에서 특정 객체를 생성하기 위해 변수와 메소드를
  정의하는 일정의 틀이다
	- 인스턴스 : 클래스에 속한 각각의 객체
	- 인스턴스화 : 클래스로부터 새로운 객체를 생성하는 것
	- 슈퍼 클래스 : 특정 클래스의 부모(상위) 클래스
	- 서브 클래스 : 특정 클래스의 자식(하위) 클래스
	*부모/자식 클래스
	: 객체지향 프로그래밍의 대표적인 특징인 상속에서 나오는 개념

캡슐화
: 객체의 속성과 행위를 하나로 묶고, 실제 구현 내용 일부를 외부에 감추어 은닉하는 방법
	- 인터페이스를 제외한 세부 내용이 은폐되어 외부에서 접근이 제한적이기
	  때문에 외부에서 변경하기 어려움
	[설명] 캡슐화를 하는 가장 큰 이유는 특정한 클래스의 메소드에 외부의 사용자가
	잘못된 사용으로 객체의 값을 손상시키지 못하게 하기 위해서 입니다.
	단순하게 말하면 보안적인 부분 때문입니다.

상속
: 이미 정의된 상위 클래스의 모든 속성과 연산은 하위 클래스가 물려받는 것
	- 하위 클래스는 부모 클래스의 모든 속성과 연산을 다시 정의하지 않고
	  사용할 수 있음
	- 하위 클래스는 상속받은 속성 외에 새로운 속성과 연산을 첨가하여
	  사용할 수 있음
	- 객체와 클래스의 재사용성을 높이는 중요한 개념
	- 다중 상속 : 한 개의 클래스가 두 개 이상의 상위 클래스로부터 상속받는 것
	[설명] 상속의 의미를 한마디로 정의하면 '재탕'입니다. 만들어 놓은 게 있으면
	다른 곳에서도 그대로 가져와서 복제된 녀석을 불러다 쓰겠다! 정도로 이해하면 됩니다.

다형성
: 하나의 객체가 여러 가지 타입을 가질 수 있는 것
	- 객체지향의 오버로딩의 개념(함수 다중 정의)
	[설명] 시험과는 무관한 얘기지만 개발자나 IT 관련 면접을 가면 그렇게
	오버로딩과 오버라이딩의 차이를 많이 물어봅니다. 완전히 다른 의미이니
	만약 IT계열 면접을 준비하신다면 오버로딩과 오버라이딩의 차이를 꼭
	검색해보고 가세요!


객체 지향 분석
: 객체 지향 분석 OOA(Object Oriented Analysis)은 사용자의 요구사항을 분석하여
  요구된 문제와 관련된 모든 객체, 클래스, 관계 등을 정의하여 모델링 하는 것

객체지향 분석 방법론
	ㄱ. 럼바우(Rumbaugh) 방법
	: 가장 일반적으로 사용되는 방법으로 분석 활동을 객체 모델, 동적 모델,
	  기능 모델로 나누어 수행하는 방법
		- 소프트웨어 구성 요소를 그래픽 표기법을 이용하여 모델링
		- 객체 > 동적 > 기능 모델링 순서
			a. 객체 모델링(Object Modeling)
			: 시스템에서 요구되는 객체를 찾아내어 속성과 연산 식별 및 객체들 간의
			  관계를 규정하여 객체 다이어그램으로 표시하는 것
			b. 동적 모델링(Dynamic Modeling)
			: 상태 다이어그램을 이용하여 시간의 흐름에 따른 객체들 간의
			  제어 흐름, 상호 작용, 동작 순서 등의 동적인 행위를 표현하는 모델링
			c. 기능 모델링(Functional Modeling)
			: 자료 흐름도(DFD)를 이용하여 다수의 프로세스들 간의 자료 흐름을
			  중심으로 처리 과정을 표현한 모델링
	ㄴ. Jacobson 방법
	: 유스케이스를 강조하여 사용하는 분석 방법
	ㄷ. 부치(Booch) 방법
	: 미시적 개발 프로세스와 거시적 개발 프로세스를 모두 사용하는 분석 방법,
	  클래스와 객체들을 분석하고 클래스 속성과 연산 정의
	ㄹ. Coad와 Yourdon 방법
	: E-R 다이어그램을 사용하여 객체의 행위를 모델링

객체지향 설계 원칙
: 시스템 변경이나 확장에 유연한 시스템을 설계하기 위해 지켜야 할 다섯 가지 원칙
  (앞 글자를 따서 solid원칙이라고도 불림)
	ㄱ. 단일 책임 원칙(Single Responsibility Principle)
	: 객체는 단 하나의 책임만 가지는 원칙
		- 응집도는 높게, 결합도는 낮게 설계하는 것을 의미
		*응집도와 결합도
		: 모듈과 관련된 개념으로 뒤에서 다루겠지만 응집도는 높을수록
		  결합도는 낮을수록 좋습니다.
	ㄴ. 개방/폐쇄 원칙(Open-Closed Principle)
	: 기존 코드를 변경하지 않고 기능을 추가할 수 있도록 설계해야 한다는 원칙
		- 공통 인터페이스를 하나의 인터페이스로 묶어 캡슐화하는 방법이 대표적
		*인터페이스
		: 구현된 것 없이 밑그림만 있는 기본 설계도, 자바 언어에서는 다른 클래스를
		  작성할 때 기본이 되는 틀을 제공하는 일종의 추상 클래스를 말함
	ㄷ. 리스코프 치환 원칙(Liskov Substitution Principle)
	: 자식 클래스는 부모 클래스에서 가능한 행위를 자식 클래스도 수행할 수 있도록
	  설계해야 한다는 원칙
		- 부모 클래스에서 정의 했다면 자식 클래스에서 재정의할 필요 없이
		  확장만 수행
	ㄹ. 인터페이스 분리 원칙(Interface Segreagation Principle)
	: 자신이 사용하지 않는 인터페이스와 의존 관계를 맺거나 영향을 받이 않아야 한다는 원칙
		- 클라이언트가 사용하지 않는 인터페이스 때문에 영향을 받아서는 안됨
	ㅁ. 의존 역전 원칙(Dependency Inversion Principle)
	: 각 객체들 간의 의존 관계가 성립될 때, 추상성이 낮은 클래스보다 추상성이 높은 클래스와
	  의존 관계를 맺어야 한다는 원칙


모듈
: 프로그래밍적 관점으로 봤을 시 프로그램을 구성하는 구성 요소의 일부분으로 독립된 하위 단위를 말함
  (예를 들면 A+B+C가 더해져서 하나의 '소프트웨어'를 이루는 상품이 있다고 가정했을 시
  상품의 하위에 해당하는 A, B, C가 모듈이라고 할 수 있음)

결합도
: 모듈 간에 상호 의존하는 정도, 또는 두 모듈 사이의 연관 관계
	- 결합도가 강할수록 시스템 구현 및 유지보수 작업이 어려움
	- 내용 > 공통 > 외부 > 제어 > 스탬프 > 자료 결합도 순으로 결합도가 낮아짐
		ㄱ. 내용 결합도(Content Coupling)
		: 다른 모듈 내부에 있는 변수나 기능을 다른 모듈에서 사용하는 경우의 결합도,
		  하나의 모듈이 직접적으로 다른 모듈의 내용을 참조할 때
		  두 모듈은 내용적으로 결합되어 있는 경우의 결합도
		ㄴ. 공통 결합도(Common Coupling)
		: 파라미터가 아닌 모듈 밖에 선언되어 있는 전역 변수를 참조하고
		  전역 변수를 갱신하는 식으로 상호작용하는 경우의 결합도
		  *파라미터
		  : 매개 변수(+파라미터 값 전달 = 변수 값 전달 정도로 이해하면 됨)
		ㄷ. 외부 결합도(External Coupling)
		: 모듈이 다수의 관련 기능을 가질 때 모듈 안의 구성요소들이
		  그 기능을 순차적으로 수행할 경우의 결합도
		ㄹ. 제어 결합도(Control Coupling)
		: 어떤 모듈이 다른 모듈의 내부 논리 조직을 제어하기 위한 목적으로 제어 신호를
		  이용하여 통신하는 경우이며, 하위 모듈에서 상위 모듈로 제어 신호가 이동하여
		  상위 모듈에게 처리 명령을 부여하는 권리 전도 현상이 발생하게 되는 결합도
		ㅁ. 스탬프 결합도(Stamp Coupling)
		: 모듈 간의 인터페이스로 배열이나 객체, 구조 등이 전달되는 경우의 결합도
		ㅂ. 자료(데이터) 결합도(Data Coupling)
		: 모듈 간의 인터페이스로 전달되는 파라미터를 통해서만 모듈 간의 상호작용이
		  일어나는 경우의 결합도

응집도
: 모듈이 독립적인 기능으로 정의되어 있는 정도를 의미
	- 응집도가 높을수록 품질이 높고 약할수록 품질이 낮음
	- 우연적 < 논리적 < 시간적 < 절차적 < 통신적 < 순차적 < 기능적 응집도 순으로 응집도가 높아짐
		ㄱ. 우연적 응집도(Coincidental Cohesion)
		: 모듈 내부의 구성요소들이 연관이 없을 경우의 응집도
		ㄴ. 논리적 응집도(Logical Cohesion)
		: 유사한 성격을 갖거나 특정 형태로 분류되는 처리요소들이 한 모듈에서
		  처리되는 경우의 응집도
		ㄷ. 시간적 응집도(Temporal Cohesion)
		: 연관된 기능이라기 보다는 특정 시간에 처리되어야 하는 활동들을 한 모듈에서
		  처리할 경우의 응집도
		ㄹ. 절차적 응집도(Procedural Cohesion)
		: 모듈이 다수의 관련 기능을 가질 때 모듈 안의 구성요소들이 그 기능을
		  순차적으로 수행할 경우의 응집도
		ㅁ. 통신적 응집도(Communication Cohesion)
		: 동일한 입/출력을 사용하여 다른 기능을 수행하는 활동들이 모여 있을 경우의 응집도
		ㅂ. 순차적 응집도(Sequential Cohesion)
		: 모듈 내에서 한 활동으로부터 나온 출력값을 다른 활동이 사용하는 경우의 응집도
		ㅅ. 기능적 응집도(Functional Cohesion)
		: 모듈 내부의 모든 기능이 단일한 목적을 위해 수행되는 경우
		[설명] 우논시절통순기 등으로 앞글자만 따서 순서를 외우고 해당하는 개념도 꼭
		숙지하셔야 합니다!
		모듈의 응집도가 높다는 것은 한 모듈 안에 독립적으로 핵심적인 기능이 잘 들어가도록
		개발 된다는 것이고, 모듈간의 결합도가 높다는 것은 모듈이 동작하기 위해서
		이 모듈, 저 모듈 유기적으로 연관되어 있어 하나로만은 제대로 동작하지 않는다는 것을
		의미합니다. 앞에서 모듈을 개발 하는 데는 많은 인력이 들어간다고 했잖아요?
		간단하게 생각하면 처음 개발할 때 신경써서 잘 개발하여 유지보수를 편하게 하느냐,
		아니면 후딱 개발해서 넘겨주고 유지보수가 X같이 어려워지느냐의 차이입니다.
		모듈화가 제대로 되어 있지 않으면 개발했던 사람조차도 오랜만에 다시 보면
		'이게 내가 작성했던 코드가 맞자?...'가 되기 쉽거든요. 단순하게 '응집도가 높을수록 좋다',
		'결합도가 낮을수록 좋다'라고 이해하는 것 보다는 위의 말을 이해한다면 훨씬 직관적으로
		문제를 푸실 수 있습니다!


N-S 차트
: 논리의 기술에 중점을 둔 도형을 이용한 표현 방법으로 박스 다이어그램이라고도 함
	- 논리의 기술에 중점을 둔 도형식 표현 방법
	- 연속, 선택 및 다중 선택, 반복 등의 제어 논리 구조로 표현
	- 조건이 복합되어 있는 곳의 처리를 시각적으로 명확히 식별하는데 사용

팬인(Fan-In) / 팬아웃(Fan-Out)
	ㄱ. 팬인
	: 어떤 모듈을 제어하는 모듈의 수
	ㄴ. 팬아웃
	: 어떤 모듈에 의해 제어되는 모듈의 수
		- 시스템 복잡도를 최적화하려면 팬인은 높게, 팬아웃은 낮게 설계해야 함

공통 모듈
: 여러 프로그램에서 공통적으로 사용할 수 있는 모듈
	- 자주 사용되는 계산식이나 매번 필요한 사용자 인증과 같은 기능들을 공통 모듈로 구성 가능
	- 아래의 다섯 가지를 준수해야 함

	구분		설명
	정확성		시스템 구현 시 해당 기능이 필요하다는 것을 알 수 있도록 정확하게 작성

	명확성		중의적으로 해석되지 않도록 명확하게 작성

	완전성		시스템 구현을 위해 필요한 모든 것을 기술

	일관성		공통 기능들 간 상호 출돌이 발생하지 않도록 작성

	추적성		기능에 대한 요구사항의 출처, 관련 시스템 등의 관계를 파악할 수 있도록 작성

재사용(Reuse)
: 개발 비용과 시간을 절약하기 위해 이미 개발하여 사용하고 있는 기능들을 파악하고 재구성하여
  새로운 기능 개발에 적용 및 최적화 시키는 작업
	- 재사용되는 대상은 외부 모듈과 결합도는 낮고, 응집도는 높아야 함

	구분		설명
	함수와 객체	클래스나 함수 단위의 소스 코드 재사용

	컴포넌트		컴포넌트 자체에 대한 수정 없이 인터페이스를 통해
			통신하는 방식으로 재사용

	애플리케이션	공통된 기능들을 제공하는 애플리케이션을 공유하는 방식으로 재사용

코드
: 컴퓨터를 이용하여 자료를 처리하는 과정에서 분류/조합/집계를 용이하게 하며,
  특정 자료 추출을 쉽게 하기 위해 사용하는 기호
	- 코드의 대표적인 5가지 기능은 식별, 분류, 배열, 표준화, 간소화 기능이 있다.

코드의 종류
	ㄱ. 순차 코드(Sequence Code)
	: 자료의 발생 순서, 크기 순서 등 일정 기준에 따라 최초의 자료부터 차례로
	  일련번호를 부여하는 방법
	ex) 1, 2, 3, 4,...
	ㄴ. 블록 코드(Block Code)
	: 공통성이 있는 것들끼리 블록으로 구분하고, 블록 내에서 일련번호를 부여하는 방법
	ex) 1~101 : 경영학과 / 2~201 : 컴퓨터 공학과 ...
	ㄷ. 10진 코드(Decimal Code) ::도서 분류식 코드
	: 코드화 대상 항목을 0~9까지 10진 분할하고, 다시 그 각각에 대하여 10진 분할하는
	  방법을 필요한 만큼 반복하는 방법
	ex) 1000 : 문학 / 1100 : 과학 / 1200 : 역사 ...
	ㄹ. 그룹 분류 코드(Group Classification Code)
	: 일정 기준에 따라 대/중/소 등으로 구분하고, 각 그룹 안에서 인력번호를 부여하는 방법
	ex) 1-1-1 : 기획팀 / 1-1-2 : 영업팀 / 1-2-1 : 본부팀
	ㅁ. 연상 코드(Mnemonic Code)
	: 대상 항목의 명칭/약호/관련있는 숫자나 문자 기호를 사용하여 코드를 부여
	ex) 14Z980 (실제 LG 그램 노트북 모델 코드)
	ㅂ. 표의 숫자 코드(Significant Digit Code)
	: 길이, 넓이, 부피, 지름, 높이 등의 물리적 수치를 그대로 코드에 적용시키는 방법으로
	  유효 숫자 코드라고도 함
	ex) 100-100-1000 : 두께X폭X길이가 100X100X1000인 유리
	ㅅ. 합성 코드(Combined Code)
	: 필요한 기능을 하나의 코드로 수행하기 어려운 경우 2개 이상의 코드를 조합하여 만드는 방법
	ex) K-600 : 한국항공 600기
	주로 연상 코드 + 순차 코드


디자인 패턴
: 각 모듈의 세분화된 역할이나 모듈들 간의 인터페이스와 같은 코드를 작성하는 수준의 세부적인 구현 방안을
  설계할 때 참조할 수 있는 전형적인 해결 방식
	- GoF의 디자인 패턴은 수많은 디자인 패턴들 중 가장 일반적인 사례에 적용될 수 있는 패턴들을
	  분류하여 정리하여, 지금까지도 현업에서 많이 사용되는 디자인 패턴입니다. 그리고 실제로
	  문제화가 가장 잘 되는 패턴이기도 합니다.
	[설명] 앞에서 배운 아키텍처 패턴이 건물의 전체적인 설계도라고 한다면
	디자인 패턴은 전체적인 설계도 밑에 해당하는 세부 설계도라고 생각하시면 됩니다.

디자인 패턴 사용의 장점
	- 범용적인 코딩 스타일로 인해 구조 파악에 용이
	- 생산성을 높일 수 있음(= 개발 시간과 비용 절약)
	- 개발자 간의 원활한 의사소통 가능
	- 변경 요청에 대한 유연한 대처 가능

디자인 패턴 사용의 단점
	- 초기 투자 비용이 높음
	- 객체지향 기반으로 한 설계와 구현을 주로 다루기에 다른 기반의
	  애플리케이션 개발에는 부적합

생성 패턴(Creational Pattern)
: 객체의 생성과 관련된 패턴으로 5개의 패턴이 있음
	ㄱ. 추상 팩토리(Abstract Factory)
	: 구체적인 클래스에 의존하지 않고, 인터페이스를 통해 서로 연관/의존하는
	  객체들의 그룹으로 생성하여 추상적으로 표현
	ㄴ. 빌더(Builder)
	: 작게 분리된 인스턴스를 건축하듯 조합하여 객체를 생성
	ㄷ. 팩토리 메서드(Factory Method)
	: 객체 생성을 서브 클래스에서 처리하도록 분리하여 캡슐화한 패턴
		- 가산 생성자 패턴이라고도 함
		- 상위 클래스에서 인터페이스만 정의, 실제 생성은 서브 클래스가 담당
	ㄹ. 프로토타입(Prototype)
	: 원본 객체를 복제하는 방법으로 객체를 생성하는 패턴
		- 일반적 방법으로 객체 생성비용이 큰 경우 주로 사용
	ㅁ. 싱글톤(Singleton)
	: 하나의 객체를 생성하면 생성된 객체를 어디서든 참조할 수 있지만,
	  여러 프로세스가 동시에 참조할 수 없음

구조 패턴(Structural Pattern)
: 클래스나 객체들을 조합하여 더 큰 구조로 만들 수 있게 해주는 패턴으로
  총 7개의 패턴이 있음
	ㄱ. 어댑터(Adapter)
	: 호환성이 없는 클래스들의 인터페이스를 다른 클래스가 이용할 수 있도록 해주는 패턴
	ㄴ. 브리지(Bridge)
	: 구현부에서 추상층을 분리하여, 서로가 독립적으로 확장할 수 있도록 구성한 패턴
		- 기능과 구현을 두 개의 별도 클래스로 구현
	ㄷ. 컴포지트(Composite)
	: 여러 객체를 가진 복합 객체와 단일 객체를 구분 없이 다루고자 할 때 사용하는 패턴
	ㄹ. 데코레이터(Decorator)
	: 객체 간의 결합을 통해 능동적으로 기능들을 확장할 수 있는 패턴
	ㅁ. 퍼싸드(Facade)
	: 복잡한 서브 클래스들을 피해 더 상위에 인터페이스를 구성함으로써
	  서브  클래스들의 기능을 간편하게 사용할 수 있도록 하는 패턴
	ㅂ. 플라이웨이트(Flyweight)
	: 인스턴스가 필요할 때마다 매번 생성하는 것이 아니라 가능한 공유해서
	  사용함으로써 메모리를 절약하는 패턴
	ㅅ. 프록시(Proxy)
	: 접근이 어려운 객체와 여기에 연결하려는 객체 사이에서 인터페이스 역할을 수행하는 패턴

행위 패턴(Behavioral Pattern)
: 클래스나 객체들이 서로 상호작용하는 방법이나 책임 분배 방법을 정의하는 패턴으로 총 11개의 패턴이 있음
	- 하나의 객체로 수행할 수 없는 작업을 여러 객체로 분배하면서 결합도를 최소화 할 수 있도록 도와줌
		ㄱ. 책임 연쇄(Chain of Responsibility)
		: 요청을 처리할 수 있는 객체가 둘 이상 존재하여 한 객체가 처리하지 못하면
		  다음 객체로 넘어가는 형태의 패턴
		ㄴ. 커맨드(Command)
		: 요청을 객체의 형태로 캡슐화하여 재이용하거나 취소할 수 있도록 요청에 필요한 정보를
		  저장하거나 로그를 남기는 패턴
			- 요청에 사용되는 각종 명령들을 추상클래스와 구체 클래스로 분리하여 단순환
		ㄷ. 인터프리터(InterPreter)
		: 언어에 문법 표현을 정의하는 패턴
		ㄹ. 반복자(Iterator)
		: 자료 구조와 같이 접근이 잦은 객체에 대해 동일한 인터페이스를 사용하도록 하는 패턴
		ㅁ. 중재자(Mediator)
		: 수많은 객체들 간의 복잡한 상호작용을 캡슐화하여 객체로 정의하는 패턴
			- 객체 사이의 의존성을 줄여 결합도를 감소
			- 중재자는 객체간의 통제와 지시 역할 수행
		ㅂ. 메멘토(Memento)
		: 특정 시점에서 객체 내부 상태를 개체화함으로써 이후 요청에 따라 객체를 해당 시점의 상태로
		  돌릴 수 있는 기능을 제공하는 패턴
		ㅅ. 옵서버(Observer)
		: 한 객체의 상태가 변화하면 객체에 상속되어 있는 다른 객체들에게 변화된 상태를 전달하는 패턴
		ㅇ. 상태(State)
		: 객체의 상태에 따라 동일한 동작을 다르게 처리해야할 때 사용하는 패턴
			- 객체 상태를 캡슐화하고 이를 참조하는 방식으로 처리
		ㅈ. 전략(Strategy)
		: 동일한 계열의 알고리즘들을 개별적으로 캡슐화하여 상호 교환할 수 있게 정의하는 패턴
			- 클라이언트는 독립적으로 원하는 알고리즘을 선택하여 사용 가능하며,
			  클라이언트에 영향 없이 알고리즘의 변경 가능
		ㅊ. 템플릿 메소드(template Method)
		: 상위 클래스에서 골격을 정의, 하위 클래스에서 세부 처리를 구체화하는 구조의 패턴
		ㅋ. 방문자(Visitor)
		: 각 클래스들의 데이터 구조에서 처리 기능을 분리하여 별도의 클래스로 구성하는 패턴
		[설명] 실제 기출 문제로 가면 Gof(Gangs of Four) 디자인 패턴 분류에 해당하지 않는 것은?/ 혹은 해당하는 것은?
		하는 식으로 문제가 출제됩니다.


인터페이스 요구사항 검증

시스템 인터페이스 요구사항 분석
: 요구사항 명세서에서 요구사항을 기능적 요구사항과 비 기능적 요구사항으로 분류하고 조직화하여
  요구사항 명세를 구체화하고 이를 이해관계자에게 전달하는 일련의 과정
	ㄱ. 기능적 요구사항
	: 시스템이 무엇을 하고 어떤 기능을 하는 가
	ㄴ. 비 기능적 요구사항
	: 시스템이나 프로젝트 개발 과정 등에서 지켜야 할 제약 사항
		- 요구사항의 분해가 필요한 경우 세분화 할 수 있음

시스템 인터페이스 요구사항 분석 절차

1단계		- 요구사항 선별
			↓
2단계		- 요구사항 관련 자료 준비
			↓
3단계		- 요구사항 분류
			↓
4단계		- 요구사항 분석 및 명세서 구체화
			↓
5단계		- 요구사항 명세서 공유

요구사항 검증 방법
: 요구사항에 대해 검증하는 방법
	ㄱ. 동료검토(Peer Review)
	: 명세서 작성자가 직접 설명하고, 동료들이 들으면서 결함을 발견하는 방법
	ㄴ. 워크스루(Walk Through)
	: 검토 회의 전 미리 명세서를 배포하여 사전 검토 후 짧은 회의를 통해
	  결함을 발견하는 방법
	ㄷ. 인스펙션(Inspection)
	: 요구사항 명세서 작성자를 제외한 다른 검토 전문가들이 요구사항 명세서를
	  확인하면서 결함을 발견하는 형태의 검토 방법
	ㄹ. 프로토타이핑(Prototyping)
	: 요구사항을 파악하기 위해 실제 개발될 소프트웨어에 대한 견본품을 만들어서
	  최종 결과물을 예측
	ㅁ. 테스트 설계
	: 테스트 케이스를 생성하여 이후에 요구사항이 현실적으로 테스트 가능한지 검토
	ㅂ. CASE(Computer Aided Software Engineering)도구 활용
	: 일관성 분석을 통해 요구사항 변경사항의 추적, 분석, 관리하고 표준 준수 여부를 확인

인터페이스 방법 명세화의 개념
: 내/외부 시스템이 연계하여 작동할 때 인터페이스별 송수신 방법, 송수신 데이터, 오류 식별 및 처리 방안에 대한
 내용을 문서화해놓은 것

시스템 연계 기술
: 개발할 시스템과 내/외부 시스템이 연계될 때 사용하는 기술
	ㄱ. DB Link
	: DB에서 제공하는 DB Link 객체 이용
	ㄴ. API/Open API
	: 송신 시스템의 DB에서 데이터를 읽어 와 제공하는 Application Programming Interface 프로그램
	  (국가의 공공데이터 포털에서 가져오는 공공 데이터 API 같은 것들을 떠올리시면 됩니다)
	ㄷ. 연계 솔루션
	: EAI(Enterprise Application Integration) 서버와 송수신 시스템에 설치되는 클라이언트 이용
	ㄹ. EAI(Enterprise Application Integration)
	: 기업 응용 프로그램 통합, 기업용 응용 프로그램의 구조적 통합 방안
	  (전사적 응용 프로그램 통합이라고도 함)
	ㅁ. Socket
	: 서버에서 소켓을 생성하여 클라이언트 통신 요청 시 클라이언트와 연결하여 통신하는 네트워크 기술
	ㅂ. Web Service
	: 웹 서비스에서 WSDL, UDDI, SOAP 프로토콜을 이용하여 연계하는 서비스
	[설명] -실기에서 중요하게 다룸
	WSDL(Web Service Description Language)
	: 웹 서비스 기술언어 또는 기술된 정의 파일의 총칭으로 XML로 기술된다.
	  웹 서비스의 구체적 내용이 기술되어 있어 서비스 제공 장소, 서비스 메시지 포맷, 프로토콜 등이 기술된다.
	UDDI(Universal Description, Discovery Intergration)
	: 웹 서비스 관련 정보의 공개와 탐색을 위한 표준이다. 서비스 제공자는 서비스 소비자에게 이미 알려진
	  온라인 저장소에 그들이 제공하는 서비스 목록들을 저장하게 되고, 서비스 소비자들은 그 저장소에
	  접근함으로써 원하는 서비스들의 목록을 찾을 수 있게 된다.
	SOAP(Simple Object Accexx Protocol)
	: 일반적으로 널리 알려진 HTTP, HTTPS, SMTP 등을 통해 XML 기반의 메시지를 컴퓨터 네트워크 상에서
	  교환하는 프로토콜이다. SOAP은 웹 서비스에서 기본적인 메시지를 전달하는 기반이 된다.

미들웨어 솔루션 명세

미들웨어
: 운영체제와 응용 프로그램 사이에서 운영체제가 제공하는 서비스 이외에 추가적인 서비스를 제공하는 소프트웨어
	- 표준화된 인터페이스를 제공하여 시스템 간의 데이터 교환, 위치 투명성 제공
	*위치 투명성
	: 접근하려는 시스템의 실제 위치를 알 필요 없이 단지 시스템의 논리적인 명칭만으로
	  액세스할 수 있다는 것을 의미

미들웨어 종류
	ㄱ. DB(Data Base)
	: 데이터베이스 벤더에서 제공하는 클라이언트에서 원격의 데이터베이스와 연결하기 위한 미들웨어
	ㄴ. RPC(Remote Procedure Call)
	: 응용 프로그램의 프로시저를 사용하여 원격 프로시저를 마치 로컬 프로시저처럼 호출하는 방식의 미들웨어
	*프로시저
	: DB에 대한 인력의 작업을 정리한 절차를 관계형 DB 관리 시스템에 저장한 것으로 DB에서 일련의 쿼리를
	  마치 하나의 함수처럼 실행하기 위한 쿼리의 집합
	*쿼리
	: 웹 서버에 특정한 정보를 보여달라는 웹 클라이언트의 요청에 의한 처리
	ㄷ. MOM(Message Oriented Middleware)
	: 메시지 기반의 비동기형 메시지를 전달하는 방식의 미들웨어
	ㄹ. TP-Monitor(Transaction Processing Monitor)
	: 항공기나 철도 예약 업무 등과 같은 온라인 트랜잭션 업무에서 트랜잭션을 처리 및 감시하는 미들웨어
	ㅁ. ORB(Object Request Broker)
	: 객체지향 미들웨어로 코바 표준 스펙을 구현한 미들웨어
	*코바
	: 네트워크 분산 프로그램 객체를 생성, 배포, 관리하기 위한 규격
	ㅂ. WAS(Web Application Server)
	: 정적인 콘텐츠를 처리하는 웹 서버와 달리 사용자의 요구에 따라 변하는 동적인 콘텐츠를
	  처리하기 위해 사용되는 미들웨어


















