개발 환경 구축
: 응용 소프트웨어 개발을 위해 개발 프로젝트를 이해하고 S/W 및 H/W 장비를 구축하는 것
*S/W(Software) : 컴퓨터 시스템을 효율적으로 운영하기 위해 개발된 프로그램의 총칭
*H/W(Hardware) : 컴퓨터를 구성하고 있는 기계 장치의 총칭

H/W 환경
	- 사용자의 인터페이스 역할을 하는 클라이언트와, 클라이언트와 통신하여 서비스하는 서버로 구성
		ㄱ. 웹 서버
			- 저용량의 정적 파일(HTML, CSS 등)을 제공
			- ex) Apache HTTP Server, Microsoft Internet Information Servie 등
		Client --------------------> Web Server
			HTTP Request
		Client <-------------------- Web Server
			HTTP Response
		ㄴ. 웹 애플리케이션 서버(Web Application Server) ::WAS
			- 사용자에게 동적 서비스를 제공하기 위해 웹 서버로부터 요청을 받아 데이터 가공 작업을 수행
			- 웹 서버와 데이터베이스 서버 또는 웹 서버와 파일 서버 사이에서 인터페이스 역할 수행
			- ex) Apache Tomcat, IBM WebSphere 등
		ㄷ. 파일 서버
		: 데이터베이스에 저장하기에는 비효율적이거나 서비스 제공 목적으로 유지하는 파일들을 저장하는 서버
			- ex) AWS, S3 등
		ㄹ. 데이터베이스 서버
		: 데이터베이스와 이를 관리하는 DBMS를 운영하는 서버
			- ex) MySQL, Werver, Oracle Server 등

S/W 환경
: 클라이언트 서버 운영을 위한 시스템 S/W와 개발에 사용되는 개발 S/W로 구성
	- 시스템 소프트웨어의 종류는 운영체제(OS), 웹 서버 및 WAS운용을 위한 서버 프로그램, DBMS등이 있음


서버 개발
: 웹 애플리케이션의 로직을 구현할 서버 프로그램을 제작하여 WAS에 탑재하는 것
	- 서버 프로그램을 개발할 수 있도록 지원하는 프레임워크가 있음

서버 개발 프레임워크
: 서버 프로그램 개발 시 다양한 설정을 손쉽게 할 수 있도록 클래스나 인터페이스를 제공하는 S/W
	- 대부분 뷰-모델-컨트롤러(MVC) 패턴을 기반으로 개발됨
	*뷰-모델-컨트롤러(MVC)
	: 흔히들 MVC패턴이라고 불리며 앞에서 봤던 개발 아키텍처 중 하나, 모델-뷰-컨트롤러로 시스템을 세부적으로 분리하여
	  서로 영향 받지 않고 개발할 수 있는 아키텍처
	- 프레임워크의 특성 : 모듈화, 재사용성, 확장성, 제어의 역 흐름
	- 대표적인 서버 개발 프레임워크는 아래와 같음
		ㄱ. Spring
			- Java 기반 프레임워크
			- 전자정부 표준 프레임워크의 기반 기술로 사용
		ㄴ. Node.js
			- Javascript 기반 프레임워크
			- 실시간으로 입출력이 빈번한 애플리케이션에 적합
		ㄷ. Django
			- Python 기반 프레임워크
			- 컴포넌트 재사용 및 플러그인화를 기반으로 신속한 개발을 지원
		ㄹ. Codeigniter
			- PHP 기반 프레임워크
			- 인터페이스가 간편하며 서버 자원을 적게 사용
		ㅁ. Ruby on Rails
			- Ruby 기반 프레임워크
			- 테스트를 위한 웹 서버 지원
			- 데이터베이스 작업을 단순화, 자동화시켜 신속한 개발 가능

서버 프로그램 구현
	- 모듈 개발 시 다른 모듈과의 과도한 상호작용을 배제함으로 써
	  특정 모듈의 수정이 다른 모듈에게 영향을 미치지 않아야 함
	- 모듈의 독립성은 결합도와 응집도에 의해 측정
	- 공통 모듈은 여러 프로그램에서 재사용할 수 있는 모듈


보안 및 API

S/W 개발 보안
: 소프트웨어 개발 과정에서 발생할 수 있는 보안 취약점을 최소화하여
  보안 위협으로부터 안전한 소프트웨어를 개발하기 위한 보안 활동
	- 데이터의 기밀성, 무결성, 가용성을 유지해야 함
	- S/W 개발 보안 가이드를 참고하여 점검해야 할 보안 항목을 점검해야 함
		ㄱ. 기밀성(Confidentiality)
		: 인가된 사람만 시스템에 접근 가능
		ㄴ. 가용성(Availability)
		: 정보는 인가받은 사용자가 필요로 하는 시점에 언제든 접근 가능해야 함
		ㄷ. 무결성(Integrity)
		: 시스템 내의 정보는 오직 인가받은 사용자만 수정할 수 있음
			(소프트웨어 보안을 철저히 하면 강력한 "무기가" 된다!)

S/W 개발 보안 점검 항목
	ㄱ. 세션 통제
		- 서버와 클라이언트의 연결 간 발생하는 정보를 관리
		- 불충분한 세션 관리 또는 잘못된 세션에 의한 정보 노출
	ㄴ. 입력 데이터 검증 및 표현
		- 입력 데이터에 대한 유효성 검증 체계를 갖추고 실패 시 이를 처리할 수 있도록 코딩하는 것
		- SQL 삽입, 경로 조작 및 자원 삽입, 크로스 사이트 스크립팅
	ㄷ. 보안 기능
		- 인증, 접근제어, 기밀성, 암호화 등의 기능
		- 적절한 인증 없는 중요 기능 허용, 부적절한 인가
	ㄹ. 시간 및 상태
		- 병렬 처리 시스템이나 다수의 프로세스가 동작하는 환경에서
		  시간과 실행 상태를 관리하여 시스템이 원활히 동작되도록 하는 것
		- 검사 시점과 사용 시점 경쟁 조건, 무한 루프, 재귀 함수
	ㅁ. 에러 처리
		- S/W 실행 중 발생할 수 있는 오류들을 사전에 정의하여
		  에러로 인해 발생할 수 있는 문제들을 예방
		- 오류 메시지를 통한 정보 노출, 오류 상황 대응 부재
	ㅂ. 코드 오류
		- 형 변환, 자원의 반환 등을 고려하여 코딩하는 것
		- 널 포인터 역참조, 부적절한 자원 해제
	ㅅ. 캡슐화
		- 데이터와 데이터를 처리하는 함수를 하나의 객체로 묶어 코딩하는 것
		- 잘못된 세션에 의한 정보 노출, 제거되지 않고 남은 디버그 코드
	ㅇ. API 오용
		- API를 잘못 사용하거나 보안에 취약한 API를 사용하지 않도록 고려하여 코딩하는 것
		- DNS lookup에 의존한 보안 결정

API(Application programming Interface)
: 응용 프로그램 개발 시 운영체제나 프로그래밍 언어 등에 있는 라이브러리를 이요할 수 있도록 규칙 등을 정의해 놓은 인터페이스
	- API는 프로그래밍 언어에서 특정한 작업을 수행하기 위해 사용
	- 개발에 필요한 여러 도구를 제공하기 때문에 이를 이용하면
	  원하는 기능을 쉽고 효율적으로 구현 가능
	- 누구나 무료로 사용할 수 있게 공개된 API를 Open API 라고 함


배치 프로그램
: 사용자와의 상호 작용 없이 미리 정해진 작업을 일괄적으로 처리하는 프로그램
	- 정기 배치 : 일, 주, 월과 같이 정해진 기간에 정기적으로 수행
	- 이벤트성 배치 : 설정한 특정 조건이 충족될 때 수행
	- On-Demand 배치 : 사용자 요청 시 수행

배치 프로그램의 필수 요소
	ㄱ. 대용량 데이터
		- 대량의 데이터를 가져오거나 전달, 계산 등의 처리가 가능해야 함
	ㄴ. 자동화
		- 심각한 오류가 발생하는 상황을 제외하고는 사용자의 개입 없이 수행되어야 함
	ㄷ. 견고성
		- 잘못된 데이터나 데이터 중복 등의 상황으로 중단되는 일 없이 수행되어야 함
	ㄹ. 안정성
		- 오류가 발생하면 오류의 발생 위치, 시간 등을 추적할 수 있어야 함
	ㅁ. 성능
		- 다른 응용 프로그램의 수행을 방해하지 않아야 하며, 지정된 시간 내에 처리가 완료 되어야 함

배치 스케줄러
: 일괄 처리 작업이 설정된 주기에 맞춰 자동으로 수행되도록 지원해주는 도구로 잡 스케줄러라고도 함
	ㄱ. 스프링 배치
	: Spring Source사와 Accenture사가 공동 개발한 오픈소스 프레임워크
		- 스프링 프레임워크의 특성을 그대로 가져와 스프링의 기능을 모두 사용할 수 있음
		- 데이터베이스나 파일의 데이터를 교환하는데 필요한 컴포넌트를 제공
		- 로그 관리 ,추적, 트랜잭션 관리, 작업 처리 통계, 작업 재시작 등의 다양한 기능 제공
		- 구성 요소 : Job, Job Launcher, Step, Job Repository
	ㄴ. Quatz
	: 스프링 프레임워크로 개발되는 응용 프로그램들의 일괄 처리를 위한 다양한 기능을 제공하는 오픈소스 라이브러리
		- 수행할 작업과 수행 시간을 관리하는 요소들을 분리하여 일괄 처리 작업에 유연성을 제공
		- 구성요소 : Shecduler, Job, JobDetail, Trigger




운영체제

- 개념 : 시스템의 자원들을 효율적으로 관리, 편리하고 효과적으로 사용 환경 제공

- 목적 : 처리 능력 향상, 사용 가능도 향상, 신뢰도 향상, 반환 시간 단축
	ㄱ. 처리 능력
	일정 시간 내에 시스템이 처리하는 일의 양
	ㄴ. 반환 시간(응답 시간)
	시스템에 작업을 의뢰한 시간부터 처리가 완료될 때까지 걸리는 시간
	ㄷ. 사용 가능도
	시스템을 사용할 필요가 있을 때 즉시 사용 가능한 정도
	ㄹ. 신뢰도
	주어진 문제를 정확하게 해결하는 정도

- 기능
	- 프로세서, 기억장치, 입/출력장치, 파일 및 정보 등의 자원 관리
	- 자원을 효율적으로 관리하기 위해 스케줄링 기능 제공
	- 사용자와 시스템 간 편리한 인터페이스 제공
	- 각종 하드웨어와 네트워크를 관리 제어
	- 데이터 관리, 데이터 및 자원의 공유 기능 제공
	- 시스템의 오류 검사 및 복구
	- 자원 보호 기능 제공
	- 입/출력에 대한 보조 기능 제공

- 주요 자원 관리
	ㄱ. 프로세스 관리
	프로세스 스케줄링 및 동기화 관리
	ㄴ. 기억장치 관리
	프로세스에게 메모리 할당 및 회수 관리
	ㄷ. 주변장치 관리
	입/출력장치 스케줄링 및 전반적인 관리
	ㄹ. 파일 관리
	파일의 생성과 삭제, 변경, 유지 등의 관리

- 종류
	Windows. UNIX, LINUX, MaxOS, MS_DOS 등

Window

- 개념 : 마이크로소프트에서 개발한 운영체제

- 특징
	ㄱ. 선점형 멀티태스킹
	동시에 여러 개의 프로그램을 실행하는 멀티태스킹을 하면서 운영체제가 각 작업의
	CPU 이용 시간을 제어하여 응용 프로그램 실행 중 문제가 발생하면 해당 프로그램을
	강제 종료시키고 모든 시스템 자원을 반환
	ㄴ. Pnp(Plug and Play)
	하드웨어를 설치할 때 해당 하드웨어를 사용하는데 필요한 시스템 환경을
	운영체제가 자동으로 구성해주는 기능
	ㄷ. OLE(Object Linking and Embedding)
	다른 응용 프로그램에서 작성된 문자나 그림 등의 개체를 현재 작성 중인 문서에
	자유롭게 연결하거나 삽입하여 편집할 수 있는 기능
	ㄹ. Single User 시스템
	컴퓨터 한대를 한 사람이 독점 사용

UNIX

- 개념 : 1960년대 AT&T 벨 연구소, MIT, General Electric이 공동 개발한 운영체제

- 특징
	- 시분할 시스템을 위해 설계된 대화식 운영체제
	- 소스코드가 개발형 시스템으로 구성되어 있음
	- 대부분 C언어로 작성되어 이식성이 높으며 장치, 프로세스 간 호환성이 높음
	- 다중 사용자(Multi-User) 및 다중 작업(Multi-Tasking)을 지원
	- 트리 구조의 파일 시스템을 가짐

- 구성
	하드웨어(물리적 장치) < 커널 < 쉘 < 유틸리티 (순으로 범위가 커짐)
	ㄱ. 커널(Kernel)
	: 하드웨어를 보호하고 프로그램과 하드웨어 간의 인터페이스 역할을 담당
		- 컴퓨터가 부팅될 때 주기억 장치에 적재된 후 상주하면서 실행됨
		- 프로세스 관리, 기억장치 관리, 파일 관리, 입출력 관리, 프로세스 간 통신,
		  데이터 전송 및 변환 등 여러 가지 기능 수행
	ㄴ. 쉘(Shell)
	: 명령어를 인식하여 수행하는 명령어 해석기
		- 시스템과 사용자 간의 인터페이스 담당
		- DOS의 COMMAND.COM과 같은 기능 수행
		- 주기억장치에 상주하지 않고 명령어가 포함된 파일 형태로 존재
		- 보조기억장치에서 교체 처리 가능
		- 파이프라인 기능 지원
		*파이프라인 : 둘 이상의 명령을 함께 묶어 처리한 결과를 다른 명령의
			     입력으로 전환하는 기능
		- 입출력 재지정을 통해 입력과 출력의 방향을 변경할 수 있음
		- 공용 Shell이나 사용자가 만들 Shell을 사용할 수 있음
	ㄷ. 유틸리티(Utility Program)
	: 사용자가 작성한 외부 프로그램을 처리
		- DOS에서의 외부 명령어에 해당
		- 에디터, 컴파일러, 인터프리터, 디버거 등

LINUX

- 개념 : 1991년 리누스 토발즈가 UNIX를 기반으로 개발한 운영체제

- 특징

	- 프로그램 소스코드가 무료로 공개되어 있어 사용자가 원하는 기능을 추가할 수 있고
	  다양한 플랫폼에 설치하여 사용이 가능하여 재배포가 가능
	- UNIX와 완벽하게 호환
	- 대부분의 특징이 UNIX와 동일

MacOS

- 개념 : 1980년대 애플사가 UNIX를 기반으로 개발한 운영체제

- 특징
	- 애플사에서 생산하는 제품에서만 사용 가능
	- 드라이버 설치 및 install / uninstall 과정이 단순

파일 디스크립터

- 개념 : 파일을 관리하기 위한 시스템이 필요로 하는 파일에 대한 정보를 가진 제어 블록을 의미

- 특징
	- 파일마다 독립적으로 존재, 시스템에 따라 다른 구조를 가질 수 있음
	- 파일 시스템이 관리하므로 사용자가 직접 참조할 수 없음
	- 보통 보조기억장치 내에 저장되어 있다가 해당 파일이 Open될 때 주기억장치로 옮겨짐



기억장치 관리

- 기억장치 계층 구조
: 기억장치는 레지스터, 캐시, 주기억장치, 보조기억장치를 계층화하여 분류할 수 있으며
  아래와 같은 특징을 가짐
	- CPU register
	- cache
	- main memory
	- disk cache
	- hard disk
	(상위의 기억장치일수록 접근 속도와 접근 시간이 빠르지만 가겨이 비싸며,
	 저장할 수 있는 용량이 적고 고가의 가격을 가짐)

- 기억장치의 관리 전략 : 반입(Fetch), 배치(Placement), 재배치(Replacement) 전략
	ㄱ. 반입 전략(Fetch)
	: 보조기억장치에 보관중인 데이터를 언제 주기억장치에 적재할 것인지를 결정하는 전략
		a. 요구 반입
		: 실행중인 프로그램이 특정 프로그램이나 데이터 등의 참조를 요구할 때 적재
		b. 예상 반입
		: 실행중인 프로그램에 의해 참조될 프로그램이나 데이터를 미리 예상하여 적재
	ㄴ. 배치 전략(Placement)
	: 새로 반입되는 데이터를 주기억장치의 어디에 위치시킬 것인지를 결정하는 전략
		a. 최초 적합(Fisrt Fit)
		: 배치가 가능한 크기의 빈 영역 중에서 첫 번째 분할 영역에 배치
		b. 최적 적합(Best Fit)
		: 배치가 가능한 크기의 빈 영역 중에서 단편화를 가장 적게 남기는 분할 영역에 배치
		c. 최악 적합(Worst Fit)
		: 배치가 가능한 크기의 빈 영역 중에서 단편화를 가장 많이 남기는 분할 영역에 배치
		*단편화
		ㄱ. 내부 단편화 : 배치 후 남은 공간
		ㄴ. 외부 단편화 : 배치를 못해 빈 공간으로 남아있는 공간
문제. 기억공간이 15K, 23K, 22K, 21K 순으로 빈 공간이 있을 때 기억장치 배치 전력으로 "First Fit"을
사용하여 17K의 프로그램을 적재할 경우 내부단편화의 크기는 얼마인가? -> 6K
	ㄷ. 교체 전략(Replacement)
	: 주기억장치의 모든 영역이 이미 사용 중인 상태에서 새로운 프로그램이나 데이터를
	  배치하려고 할 때, 이미 사용 중인 영역에서 어느 영역을 교체할 것인지를 결정하는 전략
		- FIFO, OPT, LRU, LFU, NUR, SCR 등


주기억장치 할당

- 개념 : 프로그램이나 데이터를 실행시키기 위해 주기억장치에 어떻게 할당할 것인지에 대한 내용

- 종류
	ㄱ. 연속 할당 기법
	: 프로그램을 주기억장치에 연속으로 할당하는 기법
		- 단일 분할 할당 기법 : 오버레이, 스와핑
		- 다중 분할 기법 : 고정 분할 할당 기법, 동적 분할 할당 기법
	ㄴ. 분산 할당 기법
	: 프로그램을 특정 단위의 조각으로 나누어 주기억장치 내에 분산하여 할당하는 기법
		- 페이징 기법, 세그먼테이션 기법

단일 분할 할당 기법

- 개념
: 주기억장치를 운영체제 영역과 사용자 영역으로 나누어 한순간에는 오직 한 명의 사용자만이
  주기억장치의 사용자 영역을 사용하는 기법

- 종류
	ㄱ. 오버레이 기법
	: 주기억장치보다 큰 사용자 프로그램을 실행하기 위한 기법
		- 보조기억장치에 저장된 하나의 프로그램을 여러 개의 조각으로 분할한 후
		  필요한 조각을 차례로 주기억장치에 적재하여 프로그램을 실행
	ㄴ. 스와핑 기법
	: 하나의 프로그램 전체를 주기억장치에 할당하여 사용하다 필요에 따라 다른 프로그램과
	  교체하는 기법

다중 분할 할당 기법

- 종류
	ㄱ. 고정 분할 할당 기법(Multiple Contiguous Fixed partition allocation)
	: 프로그램에 할당하기 전에 운영체제가 주기억장치의 사용자 영역을 여러 개의 고정된 크기로
	  분할하고 준비상태 큐에서 준비중인 프로그램을 각 영역에서 할당하여 수행하는 기법
		- 프로그램 실행 시 프로그램 전체가 주기억장치에 위치해야 함
		- 프로그램이 분할된 영역보다 커서 영역 안에 들어갈 수 없는 경우가 발생할 수 있음
	ㄴ. 가변 분할 할당 기법
	: 미리 주기억장치에 분할해 놓는 것이 아닌 프로그램을 주기억장치에 적재하면서
	  필요한 만큼의 크기로 영역을 분할
		- 주기억장치를 효율적으로 사용할 수 있으며, 다중 프로그래밍 정도를 높일 수 있음
		- 고정 분할 할당 기법에 비해 실행될 프로세스 크기에 대한 제약이 적음


가상기억장치

- 개념 : 보조기억장치의 일부를 주기억장치처럼 사용하는 것

- 특징
	- 용량이 작은 주기억장치를 마치 큰 용량을 가진 것처럼 사용할 수 있음
	- 프로그램을 여러 작은 블록 단위로 나누어서 가상기억장치에 보관해 놓고,
	  프로그램 실행 시 요구되는 블록만 주기억장치에 불연속적으로 할당하여 처리
	- 주기억장치의 이용률과 다중 프로그래밍의 효율 상승
	- 가상기억장치에 저장된 프로그램을 실행하려면 가상기억장치의 주소를
	  주기억장치의 주소로 바꾸는 주소 변환(Mapping) 작업이 필요
	- 연속 할당 방식에서 발생할 수 있는 단편화를 해결할 수 있음

페이징 기법

- 개념
: 가상기억장치에 보관되어 있는 프로그램과 주기억장치의 영역을 동일한 크기로 나눈 후
나눠진 프로그램을 동일하게 나눠진 주기억장치의 영역에 적재시켜 실행하는 기법

- 특징
	- 프로그램을 일정한 크기로 나눈 크기를 페이지라 하고 페이지 크기로 일정하게
	  나누어진 주기억장치의 단위를 페이지 프레임이라고 함
	- 외부 단편화는 발생하지 않으나 내부 단편화는 발생할 수 있음
	- Mapping 작업을 위해서 페이지 맵 테이블이 필요함
	- 페이지 맵 테이블 사용으로 비용이 증가되고, 처리 속도가 감소됨

세그먼트 기법

- 개념
: 가상기억장치에 보관되어 있는 프로그램을 다양한 크기의 논리적인 단위로 나눈 후
  주기억장치에 적재시켜 실행하는 방법

- 특징
	- 프로그램을 논리적인 크기로 나눈 단위를 세그먼트라고 함
	- 내부 단편화는 발생하지 않으나 외부 단편화는 발생할 수 있음
	- Mapping 작업을 위해서 세그먼트 맵 테이블이 필요함
	- 세그먼트가 주기억장치에 적재될 때 다른 세그먼트에게 할당된 영역을
	  침범할 수 없으며 이를 위해 기억장치 보호키가 필요

페이지 교체 알고리즘

- 개념
: 페이지 부재가 발생했을 때 가상기억장치의 필요한 페이지를 주기억장치에 적재해야 하는데
  이럴 경우 주기억장치의 모든 페이지 프레임이 사용 중이면 어떤 페이지 프레임을 선택하여
  교체할 것인지 결정하는 기법

- 종류 : OPT, FIFO, LRU, LFU 등
	ㄱ. OPT(Optimal replacement) ::최적 교체
	: 앞으로 가장 오랫동안 사용하지 않을 페이지를 교체하는 기법
	ㄴ. FIFO(First In First Out) - 선입선출
	: 가장 먼저 메모리에 올라온 페이지를 가장 먼저 내보내는 페이지 교체 기법
		- 이해하기 쉽고, 프로그래밍 및 설계가 상대적으로 간단함
	ㄷ. LRU(Least Recently Used)
	: 최근에 가장 오래 사용하지 않은 페이지를 교체하는 기법
		- 각 페이지마다 계수기나 스택을 두어 현 시점에서 가장 오래 사용하지 않은,
		  즉 가장 오래 전에 사용된 페이지를 교체
		*계수기
		: 각 페이지별로 존재하는 논리적 시계로, 해당 페이지가 사용될 때마다 0으로
		  클리어 시킨 후 시간을 증가시켜, 시간이 가장 오래된 페이지를 교체
	ㄹ. LFU(Least Frequently Used)
	: 사용 빈도가 가장 적은 페이지를 교체하는 기법
		- 활발하게 사용되는 페이지는 사용 횟수가 많으므로 교체되지 않고 사용
	ㅁ. NUR(Not Used Recently)
	: 최근에 사용하지 않은 페이지를 교체하는 기법
		- 최근 사용되지 않은 페이지는 향후에도 사용되지 않을 가능성이 높다는 것을 전제로,
		  LRU에서 나타나는 시간적인 오버헤드를 줄일 수 있음
	ㅂ. SCR(Second Chance Replace)
	: 가장 오랫동안 주기억장치에 있던 페이지 중 자주 사용되는 페이지의 교체를
	  방지하기 위한 것으로, FIFO 기법의 단점을 보완하는 기법

가상기억장치 기타 관리 사항

- 페이지 크기
: 페이징 기법을 사용하면 프로그램을 페이지 단위로 나누게 되는데,
  페이지의 크기에 따라 시스템에 미치는 영향이 다름

- 페이지 크기에 따른 특징
	ㄱ. 페이지 크기가 작을 경우
		- 단편화와 주기억장치로 이동하는 시간 감소
		- 불필요한 내용이 적재될 확률이 낮아 워킹 셋이 효율적으로 유지
		- Locality에 더욱 일치하여 기억장치에 효율 상승
		- 페이지 맵 테이블 크기가 커지므로 매핑 속도가 늦어짐
		- 디스크 접근 횟수가 많아져 전체적인 입출력 시간이 늘어남
	ㄴ. 페이지 크기가 클 경우
		- 단편화와 주기억장치로 이동하는 시간이 증가
		- 프로세스 수행에 불필요한 내용까지 적재될 수 있음
		- 페이지 맵 테이블 크기가 작아지므로 매핑 속도가 빨라짐
		- 디스크 접근 횟수가 줄어들어 전체적인 입출력 시간이 줄어듬

Loclity
: 프로세스가 실행되는 동안 주기억 장치를 참조할 때 일부 페이지만 집중적으로
  참조하는 성질이 있다는 이론
	- 스래싱을 방지하기 위한 워킹 셋 이론의 기반이 됨
	*스래싱
	: 컴퓨터의 가상 메모리 리소스가 과도하게 사용되어 페이징 및 페이지 오류가 지속적으로
	  발생하여 대부분의 응용 프로그램 수준 처리를 방해 할 때 발생
	- 프로세스가 집중적으로 사용하는 페이지를 알아내는 방법
	- 시간 구역성과 공간 구역성이 있음
		ㄱ. 시간 구역성
		: 프로세스가 실행되면서 하나의 페이지를 일정 시간 동안 집중적으로
		  액세스하는 현상
			- 시간 구역성이 이루어지는 기억 장소
			: 반복, 스택, 부프로그램, 1씩 증감,
							집계에 사용되는 변수
		ㄴ. 공간 구역성
		: 프로세스 실행 시 일정 위치의 페이지를 집중적으로 액세스하는 현상
			- 공간 구역성이 이루어지는 기억 장소
			: 배열 순회, 순차적 코드의 실행, 프로그래머들이 관련된 변수들을
			  서로 근처에 선언하여 할당되는 기억 장소

워킹 셋(Working Set)
: 프로세스가 일정 시간 동안 자주 참조하는 페이지들의 집합
	- 자주 참조되는 워킹 셋을 주기억장치에 상주시켜 페이지 부재 및 페이지 교체 현상이 줄어들어
	  프로세스의 기억장치 사용이 안정됨
	- 시간이 지남에 따라 자주 참조하는 페이지들의 집합이 변하기에 워킹 셋은 시간에 따라 변화

페이지 부재 빈도 방식
: 프로세스 실행 시 참조할 페이지가 주기억장치에 없는 현상으로 페이지 부재 빈도는
  페이지 부재가 일어나는 횟수를 의미
	- 부재율이 하한선을 넘어가면 페이지 프레임을 회수하는 방식을 사용

프리페이징(Prepaging)
: 처음의 과도한 페이지 부재를 방지하기 위해 필요한 것 같은 모든 페이지를
  한꺼번에 페이지 프레임에 적재하는 기법

스래싱(Thrashing)
: 프로세스의 처리 시간보다 페이지 교체에 소요되는 시간이 더 많아지는 현상
	- 다중 프로그래밍 시스템이나 가상기억장치를 사용하는 시스템에서
	  하나의 프로세스 수행 중 자주 페이지 부재가 발생하면서 나타나는 현상
	- 전체 프로세스 성능이 저하됨
	- 다중 프로그래밍의 정도가 높아짐에 따라 CPU의 이용률은 어느 특정 시점까지는 높아지지만
	  다중 프로그래밍의 정도가 더욱 커지면 스래싱이 나타나고 CPU의 이용률은 급격히 감소됨

스래싱 현상 방지 방법
	- 다중 프로그래밍의 정도를 적정 수준으로 유지
	- 페이지 부재 빈도를 조절하여 사용
	- 워킹 셋 유지
	- 부족한 자원 증설, 일부 프로세스 중단
	- CPU 성능에 대한 자료의 지속적 관리 및 분석으로 임계치를 예상하여 운영


프로세세의 개요

프로세스
: 프로세서에 의해 처리되는 사용자 프로그램이나 시스템 프로그램을 의미
	- 실행 중인 프로그램을 의미하며 작업 혹은 태스크라고도 함

PCB(Process Control Block) ::프로세스 제어 블록
: 운영체제가 프로세스에 대한 중요한 정보를 저장해 놓은 곳 (= 프로세스 단위로 정보를 저장하는 블록)
	- PCB에서 가지고 있는 정보
	: 프로세스의 현재 상태, 포인터, 프로세스 고유 식별자, 스케줄링 및 프로세스의 우선순위,
	  CPU 레지스터 정보, 주기억장치 관리 정보, 입/출력 상태 정보, 계정 정보

프로세스 상태 전이
: 프로세스가 시스템 내에 존재하는 동안 프로세스의 상태가 변화하는 것을 의미
	ㄱ. 제출(Submit)
	: 작업을 처리하기 위해 사용자가 작업을 시스템에 제출
	ㄴ. 접수(Hold)
	: 제출된 작업이 스풀 공간인 디스크의 할당 위치에 저장된 상태
	ㄷ. 준비(Ready)
	: 프로세스가 프로세서를 할당받기 위해 대기중인 상태
	ㄹ. 실행(Run)
	: 준비상태 큐에 있는 프로세스가 프로세서를 할당받아 실행되는 상태
		- 수행이 완료되기 전에 프로세스에게 주어진 프로세서 할당 시간이 종료되면
		  프로세스는 준비상태로 전이
		- 실행중인 프로세스에 입/출력 처리가 필요하면 실행중인 프로세스는
		  대기 상태로 전이
	ㅁ. 대기(Wait)
	: 프로세스에 입/출력 처리가 필요하면 현재 실행중인 프로세스가 중단되고,
	  입/출력 처리가 완료될 때까지 대기하고 있는 상태
	ㅂ. 종료(Terminated)
	: 프로세스 실행이 끝나고 프로세스 할당이 해제된 상태
	ㅅ. Dispatch(준비 -> 실행)
	: 준비 상태에 대기하고 있는 프로세스 중 하나가 프로세스를 할당받아
	  실행 상태로 전이되는 과정
	ㅇ. Wake up(대기 -> 준비)
	: 입출력 작업이 완료되어 프로세스가 대기 상태에서 준비 상태로 전이되는 과정
	ㅈ. Spooling(접수 -> 디스크)
	: 입출력 장치의 공유 및 상대적으로 느린 입출력장치의 처리 속도를 보완하기 위해
	  입출력할 데이터를 직접 장치에 보내지 않고 나중에 한거번에 입출력하기 위해
	  디스크에 저장하는 과정
	ㅊ. 교통량 제어기
	: 프로세스의 상태에 대한 조사와 통보를 담당

스레드(Thread)
: 프로세스 내에서의 작업 단위로서 시스템의 여러 자원을 할당받아 실행하는 프로세스 단위
	- 프로세스의 일부 특성을 가지고 있어 경량 프로세스라고도 함
	- 동일 프로세스 환경에서 독립적인 다중 수행 가능
	- 하나의 스레드가 존재하는 경우에는 단일 스레드,
	  하나 이상의 스레드가 존재하는 경우에는 다중 스레드라고 함

스레드의 분류
	- 사용자 수준의 스레드
	: 사용자가 만든 라이브러리를 사용하여 운용하기 때문에 속도는 빠르지만 구현이 어려움
	- 커널 수준의 스레드
	: 운영체제의 커널에 의해 스레드를 운영하기 때문에 속도는 느리지만 구현이 쉬움

스레드 사용의 장점
	- 하나의 프로세스를 여러 개의 스레드로 생성하여 병행성을 증진할 수 있음
	- H/W, O/S의 성능과 응용 프로그램의 처리율을 향상시킬 수 있음
	- 응용프로그램의 응답 시간을 단축시킬 수 있음
	- 프로세스들 간의 통신이 향상
	- 공통적으로 접근 가능한 기억장치를 통해 효율적으로 통신


스케줄링
: 프로세스가 생성되어 실행될 때 필요한 시스템의 여러 자원을 해당 프로세스에게 할당하는 작업으로
  CPU나 자원을 효율적으로 사용하기 위한 정책
	- 프로세스가 생성되어 완료될 때까지 여러 종류의 스케줄링 과정을 거침
	- 스케줄링 종류에는 장기, 중기, 단기 스케줄링이 있음

문맥 교환
: 하나의 프로세스에서 다른 프로세스로 CPU가 할당되는 과정에서 발생되는 것
	- 새로운 프로세스에 CPU를 할당하기 위해 현재 CPU가 할당된 프로세스의 상태 정보 저장
	- 새로운 프로세스의 상태 정보를 설정한 후 CPU를 할당하여 실행하도록 하는 작업

스케줄링의 목적
: CPU나 자원을 효율적으로 사용하기 위한 정책
	ㄱ. 공정성 : 모든 프로세스에게 공정하게 할당
	ㄴ. 처리율(처리량) 증가 : 단위 시간당 프로세스를 처리하는 비율 혹은 양을 증가
	ㄷ. CPU 이용률 증가
	: CPU의 낭비 시간을 줄이고 CPU가 순수 프로세스를 실행하는데 사용되는 시간 비율 증가
	ㄹ. 우선순위 제도 : 우선순위가 높은 프로세스를 먼저 실행
	ㅁ. 오버헤드 최소화 : 어떤 처리하기 위해 들어가는 간접적인 처리시간이나 메모리를 최소화
	ㅂ. 응답시간 최소화 : 작업을 지시하고 반응하기 시작하는 시간을 최소화
	ㅅ. 반환 시간 최소화 : 프로세스를 제출한 시간부터 실행이 완료될 때까지 걸리는 시간 최소화
	ㅇ. 대기 시간 최소화 : 프로세스가 준비상태 큐에서 대기하는 시간 최소화
	ㅈ. 균형 있는 자원의 사용
	ㅊ. 무한 연기 회피

프로세스 스케줄링의 기법
	ㄱ. 비선점 스케줄링(Non-Preemptive)
	: 이미 할당된 CPU를 다른 프로세스가 강제로 빼앗아 사용할 수 없는
	  강제 종료가 불가능한 스케줄링 기법
		- 프로세스가 CPU를 할당받으면 완료될 때까지 사용
		- 프로세스 응답 시간 예측이 용이
		- 일괄 처리 방식에 적합
		- 중요한(짧은) 작업이 중요하지 않은(긴) 작업을 기다리는 경우가 발생할 수 있음
		- FCFS, SJF, 우선순위, HRN, 기한부 등의 알고리즘
	ㄴ. 선점 스케줄링(Preemptive)
	: 하나의 프로세스가 CPU를 할당받아 사용하고 있을 때 우선순위가 높은 다른 프로세스가
	  CPU를 강제로 빼앗아 사용할 수 있는 스케줄링 기법
		- 우선순위가 높은 다른 프로세스가 CPU를 강제로 빼앗아 사용할 수 있음
		- 우선순위가 높은 프로세를 빠르게 처리할 수 있음
		- 빠른 응답 시간을 요구하는 대화식 시분할 시스템에 사용
		- 많은 오버헤드를 초래함
		- 선점이 가능하도록 일정 시간 배당에 대한 입터럽트용 타이머 클록이 필요
		- Round Robin, SRT, 선점 우선순위, 다단계 큐, 다단계 피드백 큐 등의 알고리즘

주요 스케줄링 알고리즘
	ㄱ. FCFS(First Come First Service) ::선입선출
	: 준비상태 큐에 도착한 순서에 따라 차례로 CPU를 할당하는 기법으로 가장 간단한 알고리즘
		- 대기 시간 : 프로세스가 대기한 시간, 바로 앞 프로세스까지의 진행 시간으로 연산
		- 반환 시간 : 프로세스의 대기 시간과 실행 시간의 합
	ㄴ. SJF(Shortest Job First) ::단기 작업 우선
	: 준비상태 큐에서 기다리고 있는 프로세스들 중에서 실행 시간이 가장 짧은 프로세스에게
	  먼저 CPU를 할당하는 기법
		- 가장 적은 평균대기 시간을 제공하는 최적 알고리즘
		- 실행 시간이 긴 프로세스는 실행 시간이 짧은 프로세스에게 할당 순위가 밀려
		  무한 연기 상태가 발생할 수 있음
	ㄷ. HRN(Hightest Response-ratio Next)
	: 실행 시간이 긴 프로세스에 불리한 SJF 기법을 보완하기 위한 것으로,
	  대기 시간과 서비스(실행) 시간을 이용하는 기법
		- 우선순위 계산 공식을 이용하여 서비스 시간이 짧은 프로세스나
		  대기 시간이 긴 프로세스에게 우선순위를 주어 CPU를 할당
		- 우선순위를 계산하여 그 숫자가 가장 높은 것부터 낮은 순으로 우선순위가 부여
		- 우선순위 계산식 - (대기시간 + 서비스시간) / 서비스시간


환경변수
: 시스템 소프트웨어의 동작에 영향을 미치는 동적인 값들의 모임

Windows 환경변수
: Windows에서 환경 변수를 명령어나 스크립트에서 사용하기 위해서는 변수명 앞뒤에 %를 붙여야 함

UNIX / LINUX 환경변수
: UNIX나 LINUX에서 환경변수를 사용하기 위해서는 변수명 앞에 $를 붙여야 함


운영체제 기본 명령어
	- CLI(Command Line Interface) : 키보드로 명령어를 입력하여 작업을 수행하는 인터페이스
	- GUI(Graphic User Interface) : 마우스로 아이콘이나 메뉴를 선택하여 작업을 수행하는 인터페이스


인터넷
: TCP/IP 프로토콜을 기반으로 전 세계 수많은 컴퓨터와 네트워크들이 연결된 광범위한 컴퓨터 통신망
	- 미 국방성의 ARPANET에서 시작
	- 유닉스 운영체제를 기반으로 함
	- 인터넷에 연결된 컴퓨터는 고유한 IP 주소를 가짐
	- 인터넷을 구성하기 위해서는 브리지, 라우터, 게이트웨이가 사용됨
	- 백본 : 네트워크를 연결하여 중추적 역할을 하는 네트워크로
		인터넷의 주가 되는 기간망을 일컫는 용어

IP주소(Internet Protocol Address)
	- 인터넷에 연결된 컴퓨터를 구분하기 위한 고유한 주소
	- 8비트 씩 4부분으로 구성됨
		A Class (50%)
		- 국가나 대형 통신망에 사용(0~127로 시작)
		- 2의 24승 = 16,777,216개의 호스팅 가능
		B Class (25%)
		- 중/대형 통신망에 사용(128~191로 시작)
		-2의 18승 = 65,536개의 호스팅 가능
		C Class (12.5%)
		- 소규모 통신망에 사용(192~223으로 시작)
		-2의 8승 = 256개의 호스팅 가능
		D Class (6.25%)
		- 멀티캐스트용으로 사용(224~239로 사용)
		E Class (6.25%)
		- 실험적 주소이며 공용되어 사용되지 않음

서브네팅(Subnetting)
: 할당된 네트워크 주소를 다시 여러 개의 작은 네트워크로 나누어 사용
	- IPv4의 주소 부족 문제를 해결하기 위한 방법
	- 서브넷 마스크 : 네트워크 주소와 호스트 주소를 구분하기 위한 비트
	- 각 클래스마다 다르게 사용하며 각 클래스별 디폴트 서브넷 마스크는 아래와 같음
		A Class : 255.0.0.0
		B Class : 255.255.0.0
		C Class : 255.255.255.0

IPv6
: 시간이 지나면서 인터넷 사용자가 많아지면서 IPv4의 주소가 부족해지게 되어
  IPv4의 주소 부족 문제를 해결하기 위해 개발됨
	- 128비트의 긴 주소를 사용하여 주소 부족 문제를 해결할 수 있고, 자료 전송 속도가 빠름
	- 인증성, 기밀성, 데이터 무결성의 지원으로 보안 문제 해결 가능
		ㄱ. 인증성 : 사용자의 식별과 접근 권한 검증
		ㄴ. 기밀성 : 시스템 내의 정보와 자료는 인가된 사용자에게만 접근 허용
		ㄷ. 무결성 : 시스템 내의 정보는 인가된 사용자만 수정 가능
	- Traffic Class, Flow Label을 이용하여 등급별, 서비스별로 패킷을 구분할 수 있어 품질 보장이 용이
		ㄱ. Traffic Class : IPv6 패킹의 클래스나 우선순위를 나타내는 필드
		ㄴ. Flow Label : 네트워크상에서 패킷들의 흐름에 대한 특성을 나타내는 필드

IPv6의 구성
	- 16비트씩 8부분, 총 128비트로 구성
	- 각 부분을 16진수로 표현하고, 콜론(:)으로 구분
	- IPv6는 아래의 3가지 주소 체계로 나뉨
		- 유니캐스트(Unicast) : 단일 송신자와 단일 수신자 간의 통신
		- 멀티캐스트(Multicast) : 단일 송신자와 다중 수신자 간의 통신
		- 애니캐스트(Anycast) : 단일 송신자와 가장 가까이 있는 단일 수신자 간의 통신

구분		IPv4		IPv6
주소 길이		32bit		128bit

표시 방법		8비트씩 4부분	16비트씩 8부분
		(10진수 표시)	(16진수 표시)

주소 개수		약 43억개		2의 128승개

주소할당 방식	클래스 단위	네트워크 규모,
		비순차 할당	단말기 수에 따라 순차 할당

브로드캐스트	있음		없음
주소

헤더 크기		가변		고정

보안		IPsec 프로토콜	IPsec 자체 지원
		별도 설치		(향상된 보안성을 가짐)


도메인 네임
: IP 주소를 사람이 이해하기 쉬운 문자 형태로 표현한 것
	- ex) http://192.168.4.10/(IP주소) -> www.google.com (도메인 네임)

도메인 네임의 구성
- ex) www.naver.com
	ㄱ. www -> World wide web의 약어 (인터넷망)
	ㄴ. naver -> 해당 페이지의 이름 (네이버, 구글 등)
	ㄷ. com -> 해당 국가 (국가에 따라 바뀜, 일본은 jp)

DNS
: 도메인 네임을 IP주소로 변환하는 역할을 하는 시스템
	- 그 역할을 하는 서버를 DNS 서버라고 함

OSI 7 Layer

OSI(Open System Interconnection) 7 Layer 참조 모델
: 다른 시스템 간의 원활한 통신을 위해 ISO(국제표준화기구)에서 제안한 통신 규약(프로토콜)으로
  컴퓨터 네트워크 프로토콜을 기능별로 나누어 각 계층으로 설명한 것
	[Data]		[Layer]

	Data		Application (Network Process to Application)
	Data		Presentation (Data representation and Encryption)
	Data		session (Interhost communication)
	Segment		Transport (End-to-End connections and Reliability)
	Packets		Network (Path Determination and IP (Logical addressing))
	Frames		Data Link (MAC and LLC (Physical addressing))
	Bits		Physical (Media, Signal and Binary Transmission)

네트워크를 계층 구조로 나눈 이유
	- 데이터의 흐름이 한눈에 보인다.
	- 하나의 문제를 7개의 작은 문제로 나누기 때문에 해결이 쉽다.
	- 각 계층마다 사용하는 장비가 다른데, 표준화를 통해 여러 회사의 네트워크 장비를
	  사용하더라도 이상 없이 작동할 수 있게 된다.

OSI 모델의 계층	(물데네전세표애)
	ㄱ. 1계층 물리 계층(Physical Layer)
	: 전송에 필요한 두 장치 간의 실제 접속과 절단 등 기계적, 전기적, 기능적, 절차적
	  특성에 대한 규칙을 정의
		- 물리적 전송 매체와 신호 방식을 정의
		- RS-232C, X.21 등의 표준
		- 관련 장비 : 리피터, 허브
		- 데이터 단위 : 비트
	ㄴ. 2계층 데이터 링크 계층(Data Link Layer)
	: 두 개의 인접 개방 시스템들 간의 신뢰성 있고 효율적인 정보 전송을 할 수 있도록 함
		- 주요 기능 : 흐름 제어, 프레임 동기화, 오류 제어, 순서 제어
		- HDLC, LAPB, LLC, MAC, LAPD, PPP 등의 표준
		- 관련 장비 : 브리지, 스위치, 랜카드
		- 데이터 단위 : 프레임
	ㄷ. 3계층 네트워크 계층(Network Layer)
	: 개방 시스템들 간의 네트워크 연결을 관리하고 데이터의 교환 및 중계 가능
		- 네트워크 연결 설정, 유지, 해제
		- 경로 설정, 데이터 교환 및 중계, 트래픽 제어, 패킷 정보 전송 수행
		- X.25, IP 등의 표준
		- 관련 장비 : 라우터
		- 데이터 단위 : 패킷
	ㄹ. 4계층 전송 계층(Transport Layer)
	: 논리적 안정과 균일한 데이터 전송 서비스를 제공
		- 종단 시스템 간의 투명 데이터 전송을 가능하게 함
		- 종단 시스템 간의 전송 연결 설정, 데이터 전송, 연결 해제 기능
		- 주소 설정, 다중화, 오류 제어, 흐름 제어
		- TCP, UDP 등의 표준
		- 관련 장비 : 게이트웨이
		- 데이터 단위 : 세그먼트
	ㅁ. 5계층 세션 계층(Session Layer)
	: 송수신측 양쪽의 관련성을 유지하고 대화 제어를 담당
		- 동기점 : 송수신 측간의 대화 동기를 위해 전송하는 정보를
			일정한 부분에 두어 정보의 수신 상태를 체크하는 포인트
		- 데이터 단위 : 메시지
	ㅂ. 6계층 표현 계층(Presentation Layer)
	: 데이터를 응용 계층, 세션 계층에 보내기 전에 계층에 맞게 변환
		- 서로 다른 데이터 표현 형태를 갖는 시스템 간 상호 접속을 위해 필요한 계층
		- 코드 변환, 데이터 암호화, 데이터 압축, 구문 검색, 정보 형식 변환, 문맥 관리 기능
		- 데이터 단위 : 메시지
	ㅅ. 7계층 애플리케이션 계층(Application Layer)
	: 사용자가 OSI 환경에 접속할 수 있도록 서비스 제공
		- 프로세스 간의 정보 교환, 전자 사서함, 가상 터미널 등의 서비스 제공


네트워크 관련 장비

네트워크 인터페이스 카드(Network Interface Card)
: 컴퓨터를 연결하는 장치로 정보 전송 시 정보가 케이블을 통해 전송될 수 있도록 정보 형태를 변경
	- 이더넷 카드(::LAN) 혹은 네트워크 어댑터라고 함

허브
: 가까운 거리의 컴퓨터를 연결하는 장치
	- 각 회선을 통합적으로 관리하며 신호 증폭 기능을 하는 리피터의 역할도 포함
	- 종류로는 더미 허브, 스위칭 허브가 있음
		ㄱ. 더미 허브
			- 네트워크에 흐르는 모든 데이터를 단순히 연결만 함
			- LAN이 보유한 대역폭을 나누어 제공
		ㄴ. 스위칭 허브
			- 네트워크상에 흐르는 데이터의 유무 및 흐름을 제어하여 각각의 노드가 허브의 최대 대역폭을
			  사용할 수 있는 지능형 허브

리피터(Repeater)
: 전송되는 신호가 원래의 형태와 다르게 왜곡되거나 약해질 경우 원래의 신호 형태로 재생하여 다시 전송하는 역할
	- 근접한 네트워크 사이에 신호를 전송
	- 전송 거리의 연장 또는 배선의 자유도를 높이는 용도

브리지(Bridge)
: LAN과 LAN을 연결하거나 LAN안에서 컴퓨터 그룹을 연결
	- 데이터 링크 계층 중 MAC 계층에서 사용되므로 MAC 브리지라고도 함
	- 현재는 스위치에 밀려 거의 사용되지 않는다.

스위치(Switch)
: LAN과 LAN을 연결하여 훨씬 더 큰 LAN을 만드는 장치
	- 포트마다 각기 다른 전송속도를 지원하도록 제어할 수 있음
	- 수십 ~ 수백 개의 포트를 지원

라우터(Router)
: LAN과 LAN의 연결 기능에 데이터 전송의 최적 경로를 선택할 수 있는 기능을 추가
	- 서로 다른 LAN이나 LAN과 WAN의 연결도 수행
	- 접속 가능한 경로에 대한 정보를 Routing Table에 저장하여 보관
	- 3계층 까지의 프로토콜 구조가 다른 네트워크 간의 연결을 위해 프로토콜 변환 기능을 수행

게이트웨이(Gateway)
: 전 계층의 프로토콜 구조가 다른 네트워크의 연결을 수행
	- LAN에서 다른 네트워크에 데이터를 송수신하는 출입구 역할을 함


프로토콜
: 서로 다른 기기들 간의 데이터 교환을 원활하게 수행할 수 있도록 표준화시켜 놓은 통신 규약

프로토콜의 기본 요소
	ㄱ. 구문(Syntax)
	: 전송하고자 하는 데이터의 형식, 부호화, 신호 레벨 등을 규정
	ㄴ. 의미(Semantics)
	: 두 기기 간의 효율적이고 정확한 정보 전송을 위한 협조 사항과 오류 관리를 위한 제어 정보를 규정
	ㄷ. 시간(Timing)
	: 두 기기 간의 통신 속도, 메시지의 순서 제어 등을 규정

프로토콜의 기능
	ㄱ. 단편화와 재결합
		a. 단편화
		: 송신 측에서 전송할 데이터를 전송에 알맞은 작은 크기의 블록으로 자르는 작업
		b. 재결합
		: 수신 측에서 수신한 단편화된 데이터를 다시 모으는 작업
	ㄴ. 캡슐화
	: 단편화 된 데이터에 주소, 오류 검출 코드, 프로토콜 제어 정보를 부가하는 것
	ㄷ. 흐름 제어
	: 수신 측에서 송신 측의 데이터 전송 속도나 전송량을 제어할 수 있는 기능
		- 정지-대기 방식이나 슬라이딩 윈도우 방식을 이용
	ㄹ. 오류 제어
	: 전송 중에 발생하는 오류를 검출하고 정정하여 데이터나 제어 정보의 파손에 대비하는 기능
	ㅁ. 동기화
	: 송수신 측이 같은 상태를 유지하도록 타이밍을 맞추는 기능
	ㅂ. 순서 제어
	: 전송되는 데이터 블록에 전송 순서를 부여하여 연결 위주의 데이터 전송 방식에 사용
		- 흐름 제어 및 오류 제어를 용이하게 함
	ㅅ. 주소 지정
	: 데이터가 목적지까지 정확하게 전송될 수 있도록 목적지 이름, 주소, 경로를 부여하는 기능
	ㅇ. 다중화
	: 한 개의 통신 회선을 여러 가입자들이 동시에 사용하도록 하는 기능
	ㅈ. 경로 제어
	: 송수신 측 간의 송신 경로 중에서 최적의 패킷 교환 경로를 설정하는 기능
	ㅊ. 전송 서비스
	: 전송하려는 데이터가 사용하도록 하는 별도의 부가 서비스


TCP/IP
: 인터넷에 연결된 서로 다른 기종의 컴퓨터들이 데이터를 주고 받을 수 있도록 하는 표준 프로토콜
	- 1960년대 말 ARPA에서 개발하여 ARPANET에서 사용하기 시작
	- UNIX의 기본 프로토콜로 사용되었다가 현재는 인터넷 범용 프로토콜로 사용
	- TCP(Transmission Control Protocol) 프로토콜과 IP 프로토콜(Internet protocal)이 결합
		ㄱ. TCP
			- OSI 4계층 전송 계층에 해당
			- 신뢰성 있는 연결형 서비스 제공
			- 패킷의 다중화, 순서 제어, 오류 제어, 흐름 제어 기능 제공
			- 스트림 전송 기능 제공
		ㄴ. IP
			- OSI 3계층 네트워크 계층에 해당
			- 데이터그램 기반으로 하는 비연결형 서비스 제공
			- 패킷의 분해/조립, 주소 지정, 경로 선택 기능 제공

응용 계층의 주요 프로토콜
	- FTP(File Transfer Protocol)
		- 컴퓨터와 컴퓨터 또는 컴퓨터와 인터넷 사이에서 파일을 주고받을 수 있도록 하는 원격 파일 전송 프로토콜
	- SMTP(Simple Mail Transfer Protocol)
		- 전자 우편 교환 서비스
	- TELNET
		- 멀리 떨어져 있는 컴퓨터에 접속하여 자신의 컴퓨터처럼 사용할 수 있도록 해주는 서비스
	- SNMP(Simple Network Management Protocol)
		- TCP/IP의 네트워크 관리 프로토콜로, 라우터나 허브 등 네트워크 기기의 네트워크 정보를
		  네트워크 관리 시스템에 보내는데 사용하는 통신 규약
	- DNS(Domain Name System)
		- 도메인 네임을 IP주소로 매핑하는 시스템
	- MQTT(Message Queuing Telemetry Transport)
		- 발생-구독 기반의 메시징 프로토콜로, IoT환경에서 자주 사용

전송 계층의 주요 프로토콜
	- TCP(Transmission Control Protocol)
		- 양방향 연결형 서비스 제공
		- 가상 회선 서비스 제공
		- 스트림 위주의 패킷 전달
		- 순서 제어, 오류 제어, 흐름 제어
		- 패킷의 분실, 손상, 지연이나 순서가 틀린 것 등이 발생할 때 투명성이 보장되는 통신 제공
	- UDP(User Datagram Protocol)
		- 데이터 전송 전에 연결 설정을 하지 않는 비연결형 서비스 제공
		- TCP에 비해 상대적으로 단순한 헤더 구조를 가짐,
		  오버헤드가 적고, 흐름제어나 순서 제어가 없어 전송 속도가 빠름
		- 고속의 안정성 있는 전송 매체를 사용하여 빠른 속도로 필요로 하는 경우,
		  동시에 여러 사용자에게 데이터를 전달할 경우, 정기적으로 반복해서 전송할 경우 사용
	- RTCP(Real-Time Control Protocol)
		- 패킷의 전송 품질을 제어하기 위한 제어 프로토콜
		- 세션에 참여한 각 참여자들에게 주기적으로 제어 정보 전송
		- RTCP 패킷은 항상 32비트의 경계로 끝남

인터넷 계층의 주요 프로토콜
	- IP(Internet Protocol)
		- 전송할 데이터에 주소를 지정하고 경로를 설정하는 기능
	- ICMP(Internet Control Massage Protocol)
		- IP와 조합하여 통신 중에 발생하는 오류의 처리와 전송 경로 변경들을 위한 제어 메시지를
		  관리하는 역할을 하며, 헤더는 8Byte로 구성
	- IGMP(Internet Group Management Protocol)
		- 멀티캐스트를 지원하는 호스트나 라우터 사이에서 멀티캐스트 그룹 유지를 위해 사용
	- ARP(Address Resolution Protocol)
		- 호스트의 IP주소를 호스트와 연결된 네트워크 접속 장치의 물리적 주소로 바꿈
	- RARP(Reverse address Resolution Protocol)
		- ARP와 반대로 물리적 주소를 IP주소로 변환하는 기능을 함

네트워크 액세스 계층의 주요 프로토콜
	- Ethernet(IEEE 802.3)
		- CSMA/CD 방식의 LAN
	- IEEE 802
		- LAN을 위한 표준 프로토콜
	- HDLC
		- 비트 위주의 데이터 링크 제어 프로토콜
	- X.25
		- 패킷 교환망을 통한 DTE와 DCE 간의 인터페이스를 제공하는 프로토콜
	- RS.232C
		- 공중전화 교환망(PSTN)을 통한 DCE 간의 인터페이스를 제공하는 프로토콜





















