자료 구조
: 프로그램에서 사용하기 위한 자료를 기억장치의 공간 내에 저장하는 방법과
 저장된 그룹 내에 존재하는 자료 간의 관계, 처리 방법 등을 연구 분석하는 것을 말함
	[설명] 자료 구조에 해당하는 내용은 실기의 프로그래밍 파트를 이해하는데 기반이 되므로
	급박하게 공부하는 것이 아니라면 하나하나 이해하고 암기하면서 가는 것이 추후 시간 절약에
	많은 도움이 될 것입니다. 만약 자료구조가 정말 이해가 가지 않는다면 일단은 필기 문제를
	먼저 풀어보고 문제에서 나오는 부분 위주로 선 암기 후 이해를 하셔도 됩니다.

			----------	배열
			----------	선형 리스트--------	연속 리스트
		선형 구조			연결 리스트
			----------	스택
			----------	큐
			----------	덱(데크)
자료구조-----------

		비선형 구조--------	트리
			   -------	그래프

			[자료 구조]

배열
: 동일한 자료형의 데이터들이 같은 크기로 나열되어 순서를 갖고 있는 집합 -> ex) {1, 2, 3, 4, 5}
	- 첨자(index)를 이용하여 데이터에 접근
	- 첨자의 개수에 따라 n차원 배열이라 부름
	- 기억장소의 추가가 어렵고, 데이터 삭제 시 저장되어 있던
	  기억 장소는 빈 공간으로 남아있어 메모리 낭비가 발생
	- 반복적인 데이터 처리 작업에 적합한 구조
	a[0]	a[1]	a[2]	a[3]	...	a[n-1]

리스트
: 자료를 나열한 목록(일반적으로 아래와 같은 표 형태)

	이름		주소		출석번호		이메일
	kim		seoul		99		abc@naver.com
	you		tokyo		77		test@naver.com
	lee		busan		33		as@daum.net

선형 리스트(Linear List)
: 일정한 순서에 의해 나열된 자료 구조
	- 배열을 이용하는 연속 리스트와 포인터를 이용하는 연결 리스트로 구분
	*포인터
	: 프로그래밍 언어에서 다른 변수, 혹은 그 변수의 메모리 공간 주소를 가리키는
	  변수를 말함, 포인터가 가리키는 값을 가져오는 것을 역참조라고 함
	  포인터는 어셈블리어, C, 파스칼, 등 하위 레벨까지 제어할 수 있는 언어에서 주로 쓰임
		ㄱ. 연속 리스트(Contiguous List)
		: 배열과 같이 연속되는 기억장소에 저장되는 자료 구조
			- 중간에 데이터를 삽입하기 위해 연속된 빈 공간이 있어야 하며
			  삽입, 삭제 시 자료의 이동 필요
		ㄴ. 연결 리스트(Linked List)
		: 자료 항목의 순서에 따라 노드의 포인터 부분을 이용하여 서로 연결시킨 자료 구조
			- 노드의 삽입.삭제 작업이 용이
			- 기억 공간이 연속적으로 놓여 있지 않아도 저장 가능
			- 링크(포인터) 부분이 필요하기 때문에 순차 리스트에 비해 기억 공간의
			  효율이 좋지 않음
			- 포인터를 찾는 시간이 필요하기 때문에 접근 속도가 느리다.

스택(Stack)
: 리스트의 한쪽 끝으로만 자료의 삽입, 삭제 작업이 이루어지는 자료 구조
	- 가장 나중에 삽입된 자료가 가장 먼저 삭제되는 후입선출(LIFO; Last In First Out) 방식으로 자료를 처리
	- 꽉 채워져 있는 상태에서 삽입되면 오버플로(Overflow),
	  비어 있는 상태에서 삭제하면 언더플로(Underflow)가 발생
	  (삽입(스택에 쌓임) PUSH, 삭제(출력) POP)
	- TOP : 가장 마지막으로 삽입된 자료가 기억된 위치를 가리키는 요소
	- Bottom : 스택의 가장 밑바닥 자료
	- Overflow : 스택 공간이 가득 찼는데 추가적인 데이터를 넣으려고 할 때 발생
	- Underflow : Top Pointer가 주소 0을 가지고 있다면 스택에서 삭제할 자료가 없어지므로 발생
	  (한마디로 삭제하려고 하는데 삭제할 값이 없을 때 발생)

큐(Queue)
: 리스트의 한쪽에서는 삽입 작업이 이루어지고 다른 한쪽에서는
  삭제 작업이 이루어지도록 구성한 자료 구조
	- 가장 먼저 삽입된 자료가 가장 먼저 삭제되는 선입선출(FIFO; First In First Out) 방식으로 처리
	- 시작과 끝을 표시하는 두 개의 포인터가 있다.

트리(Tree)
: 정점과 선분을 이용하여 사이클을 이루지 않도록 구성한 그래프(Graph)의 특수한 형태
	ㄱ. 노드(Node)
	: 하나의 기억 공간
	ㄴ. 링크(Link)
	: 노드와 노드를 연결하는 선
	ㄷ. 근 노드(Root Node)
	: 트리의 맨 위에 있는 노드 / A
	ㄹ. 디그리(Degree, 차수)
	: 각 노드에서 뻗어 나온 가지의 수 / A=3, B=2, C=1, D=3
	ㅁ. 단말 노드(Terminal Node) = 잎 노드(Leaf Node)
	: 자식이 하나도 없는 노드 / K, L, F, G, M, I, J
	ㅂ. 자식 노드(Son Node)
	: 어떤 노드에 연결된 다음 레벨의 노드들 / D의 자식 노드 : H, I, J
	ㅅ. 부모 노드(Parent Node)
	: 어떤 노드에 연결된 이전 레벨의 노드들 / E, F의 부모 노드 : B
	ㅇ. 형제 노드(Brother Node, Sibling)
	: 동일한 부모를 갖는 노드들 / H의 형제 노드 : I, J
	ㅈ. 트리의 디그리
	: 노드들의 디그리 중에서 가장 많은 수 / 노드 A나 D가 3개의 디그리를 가지므로 위 트리의 디그리는 3

					A(근 노드)				Level 1

		B			C			D		Level 2

	E		F		G		H	I	J	Level 3

        K	     L						M			Level 4 -> Depth

트리 운행법
: 트리를 구성하는 각 노드들을 찾아가는 방법
	ㄱ. Preorder 운행(:: 전위 운행)
	: Root -> Left -> Right 순서
	ㄴ. Inorder 운행 (:: 중위 운행)
	: Left -> Root -> Right 순서
	ㄷ. Postorder 운행 (:: 후위 운행)
	: Left -> Right -> Root 순서

수식의 표기법
: 산술식을 계산하기 위해 기억공간에 기억시키는 방법으로 이진트리를 많이 사용

		+
	A		B

	ㄱ. 전위 표기법(PreFix)
	: 연산자 -> Left -> Right 순서 ::+AB
	ㄴ. 중위 표기법(inFix)
	: Left -> 연산자 -> Right 순서 ::A+B
	ㄷ. 후위 표기법(PostFix)
	: Left -> Right -> 연산자 순서 ::AB+


정렬 알고리즘
: 컴퓨터 과학과 수학에서 정렬 알고리즘이란 원소들을 번호순이나 사전 순서와 같이
  일정한 순서대로 열거하는 알고리즘이다. 효율적인 정렬은 탐색이나 병합 알고리즘처럼
  (정렬된 리스트에서 바르게 동작하는) 다른 알고리즘을 최적화하는데 중요하다.
*알고리즘
: 셈법은 수학과 컴퓨터과학, 언어학 또는 엮인 분야에서 어떠한 문제를 해결하기 위해 정해진 일련의 절차
	ㄱ. 삽입 정렬(Insertion Sort)
	: 가장 간단한 정렬 방식으로 이미 순서화된 파일에 새로운 하나의 레코드를
	  순서에 맞게 삽입시켜 정렬
		- 앞에서부터 순차적으로 값을 비교하여 크기가 작은 값을 앞의 값과 변경

		[삽입 정렬 예시]
		8 5 6 2 4
	1회	8 5 6 2 4 -> 5 8 6 2 4	2번째 값과 1번째 값 비교하여 변경 후 한칸씩 뒤로 밈
	2회	5 8 6 2 4 -> 5 6 8 2 4	3번째 값과 1,2번째 값 비교 비교하여 변경 후 한칸씩 뒤로 밈
	3회	5 6 8 2 4 -> 2 5 6 8 4	4번째 값과 1,2,3번째 값 비교 비교하여 변경 후 한칸씩 뒤로 밈
	4회	2 5 6 8 4 -> 2 4 5 6 8	5번째 값과 1,2,3,4번째 값 비교 비교하여 변경 후 한칸씩 뒤로 밈

	ㄴ. 쉘 정렬(Shell Sort)
	: 삽입 정렬을 확장한 개념
		- 입력 파일이 부분적으로 정렬되어 있는 경우 유리한 방식
		- 입력 파일을 어떤 매개변수 값으로 서브파일을 구성하고 각 서브파일을
		  Insertion 정렬 방식으로 순서 배열하는 과정을 반복하는 정렬
	ㄷ. 선택 정렬(Selection Sort)
	: n개의 레코드 중에서 최소값을 찾아 첫 번째 레코드 위치에 놓고 나머지 (n-1)개 중에서
	  다시 최소값을 찾아 두 번째 레코드 위치에 놓는 방식을 반복하는 정렬

		[선택 정렬 예시]
		8 5 6 2 4
	1회	8 5 6 2 4 -> 5 8 6 2 4 -> 2 8 6 5 4 -> 2 8 6 5 4	1~n-1까지 순차 비교 후 변경이 필요하면 변경
	2회	2 6 8 5 4 -> 2 5 8 6 4 -> 2 4 8 6 5
	3회	2 4 6 8 5 -> 2 4 5 8 6
	4회	2 4 5 6 8

	ㄹ. 버블 정렬(Bubble Sort)
	: 주어진 파일에서 인접한 두 개의 레코드 키 값을 비교하여
	  크기에 따라 레코드 위치를 서로 교환하는 정렬

		[버블 정렬 예시]
		8 5 6 2 4
	1회	5 8 6 2 4 -> 5 6 8 2 4 -> 5 6 2 8 4 -> 5 6 2 4 8
	2회	5 6 2 4 8 -> 5 2 6 4 8 -> 5 2 4 6 8
	3회	5 2 4 6 8 -> 2 5 4 6 8 -> 2 4 5 6 8

	ㅁ. 퀵 정렬(Quick Sort)
	: 레코드의 많은 자료 이동을 없애고 하나의 파일을 부분적으로
	  나누어가면서 정렬
		- 위치에 관계없이 임의의 키를 분할 원소로 사용 가능
		- 프로그램에서 되부름을 이용하기에 스택이 필요
		- 분할과 정복을 통해 자료를 정렬
	ㅂ. 힙 정렬(Heap Sort)
	: 정렬할 입력 레코드들로 힙을 구성하고 가장 큰 키 값을 갖는 루트 노드를
	  제거하는 과정을 반복하여 정렬
		- 구성된 전이진 트리를 Heap Tree로 변환하여 정렬
		- 완전 이진 트리로 입력 자료의 레코드를 구성
	ㅅ. 2-Way 합병 정렬(Merge Sort)
	: 이미 정렬되어 있는 두 개의 파일을 한 개의 파일로 합병하는 정렬
		- 두 개의 키들을 한 쌍으로 하여 각 쌍에 대해 순서를 정함
		- 순서대로 정렬된 각 쌍의 키들을 합병하여 하나의 정렬된 서브리스트로 만듬
		- 위의 두 과정을 하나의 정렬된 파일이 될 때까지 반복

정렬 시간 복잡도

	이름		최고		평균		최악
	삽입 정렬		n		n^2		n^2
	선택 정렬		n^2		n^2		n^2
	버블 정렬		n^2		n^2		n^2
	셸 정렬		n		n^1.5		n^2
	퀵 정렬		nlog(2)n		nlog(2)n		n^2
	힙 정렬		nlog(2)n		nlog(2)n		nlog(2)n


데이터베이스 개요

데이터저장소
: 소프트웨어 개발 과정에서 다루어야 할 데이터들을 논리적인 구조로 조직화하거나 물리적인 공간에 구현한 것

데이터베이스(Data Base)
: 특정 조직의 임무를 수행하는데 필요한 상호 관련된 데이터들의 모임
	- 데이터베이스는 여러 사람에 의해 공통으로 사용될 데이터를 중복을 배제하여 통합하고,
	  쉽게 접근하여 처리할 수 있도록 저장장치에 저장하여 항상 사용할 수 있도록 운영하는 운영 데이터

DBMS(Data Base Management System)
: 데이터베이스 사이에서 사용자의 요구에 따라 정보를 생성해 주고, 데이터 베이스를 관리해 주는 소프트웨어를 총칭

스키마(Schema)
: 데이터베이스의 구조와 제약 조건에 관한 전반적인 명세를 기술한 메타 데이터의 집합
*메타 데이터
: 데이터에 대한 설명. 메타 데이터가 모이면 데이터 사전이 됨
	- 스키마는 사용자의 관점에 따라 외부 스키마, 개념 스키마, 내부 스키마로 나뉨
		ㄱ. 외부 스키마
		: 사용자, 응용 프로그래머가 각각의 입장에서 필요로 하는 데이터베이스의 논리적 구조 정의
		ㄴ. 개념 스키마
		: 데이터베이스의 전체적인 논리적 구조로, 모든 응용 프로그램이나 사용자들이 필요로 하는
		데이터를 종합한 조직 전체의 데이터 베이스로 단 하나만 존재함
			- 개체 간의 관계와 제약 조건 명시
		ㄷ. 내부 스키마
		: 물리적 저장장치의 입장에서 본 데이터베이스 구조로서,
		  실제로 데이터베이스에 저장될 레코드의 형식을 정의

데이터 입출력
: 소프트웨어의 기능을 구현하기 위해 데이터베이스에 데이터를 입력, 출력하는 작업

SQL(Structured Query Language 구조화 질의어)
: 국제 표준 데이터베이스 언어
	- 데이터 정의어(DDL), 조작어(DML), 제어어(DCL)로 구분됨

트랜잭션
: 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 수행돼야 할 일련의 연산
	- TCL(Transaction control Language) : 트랜잭션을 제어하기 위해 사용되는 명령어
		ㄱ. COMMIT
		: 트랜잭션 처리가 정상적으로 종료되어 트랜잭션이 수행한 변경 내용을
		  데이터베이스에 반영
		ㄴ. ROLLBACK
		: 트랜잭션 처리가 비정상적으로 종료되어 데이터베이스의 일관성이 깨졌을 때
		  트랜잭션이 행한 모든 변경 작업을 취소하고 이전 상태로 되돌림
		ㄷ. SAVEPOINT(CHECKPOINT)
		: 트랜잭션 내에 ROLLBACK 할 위치인 저장점을 지정

절차형 SQL
: 프로그래밍 언어와 같이 연속적인 실행이나 분기, 반복 등의 제어가 가능한 SQL
	- 단일 SQL문장으로 처리가 어려운 연속적인 작업을 처리하는데 적합
	- BEGIN ~ END 형식의 블록 구조로 되어 있어 기능별 모듈화가 가능


단위 모듈
: 단위 모듈은 소프트웨어 구현에 필요한 여러 동작 중 한 가지 동작을 수행하는 기능을 모듈로 구현한 것

단위 모듈 구현 순서
	- 단위 기능 명세서 작성 -> 입출력 기능 구현 -> 알고리즘 구현

단위기능 명세서 작성
: 단위 기능을 명세화한 문서
	- 복잡한 시스템을 단순하게 구현하기 위한 추상화 작업이 필요
	- 대형 시스템을 분해하여 단위 기능별로 구분하고 각 기능들로 계층적으로
	  구성하는 구조화 과정을 거침

입출력 기능 구현
: 단위 기능 명세서에서 정의한 데이터 형식에 따라 입출력 기능을 위한 알고리즘 및 데이터 구현
	- 모듈 간 연동 또는 통신을 위한 데이터 구현

알고리즘 구현
: 입출력 데이터를 바탕으로 단위 기능별 요구 사항들을 구현 가능 언어를 이용하여 모듈로 구현

IPC(Inter Process Communication)
: 모듈 간 통신을 구현하기 위해 사용되는 프로그래밍 인터페이스 집합
*인터페이스
: 서로 다른 두 개의 시스템, 장치 사이에서 정보나 신호를 주고받는 경우의 접점이나 경계면이다.
  즉, 사용자가 기기를 쉽게 동작시키는데 도움을 주는 시스템을 의미
	ㄱ. 공유 메모리(Shared Memory)
	: 다수의 프로세스가 공유 가능한 메모리를 구성하여 통신 수행
	ㄴ. 소켓(Socket)
	: 네트워크 소켓을 이용하여 네트워크를 경유하는 통신 수행
	ㄷ. 세마포어(Semaphores)
	: 공유 자원에 대한 접근 제어를 통해 통신 수행
		- 임계 구역의 접근을 제어하는 상호배제 기법
	ㄹ. 파이프(Pipes)
	: 선입선출의 형태로 구성된 메모리를 여러 프로세스가 공유하여 통신 수행
	ㅁ. 메시지 큐잉(Message Queueing)
	: 메시지가 발생하면 이를 전달하는 형태로 통신 수행

단위 모듈 테스트
: 모듈이 정해진 기능을 정확히 수행하는지 검증
	- 단위 테스트라고도 하며 화이트박스 테스트와 블랙박스 테스트 기법 사용
	- 시스템 수준의 오류는 발견할 수 없음
	*화이트박스 테스트
	: 모듈의 소스 코드를 오픈시킨 상태에서 소스 코드의 모든 논리적인 경로를 테스트하는 방법
	*블랙박스 테스트
	: 소프트웨어가 수행할 특정 기능이 완전히 작동되는 것을 입증하는 테스트

테스트 케이스
: 구현된 소프트웨어가 요구사항을 정확히 준수했는지 확인하기 위한 테스트 항목에 대한 명세서로
  명세 기반 테스트의 설계 산출물에 해당
	- 입력 데이터, 테스트 조건, 예상 결과 등을 모아 테스트 케이스를 만듬
	- 테스트 케이스의 구성 요소 : 식별자, 테스트 항목, 입력/출력 명세, 환경 설정, 특수 절차 요구, 의존성 기술

테스트 프로세스
: 테스트를 위해 수행하는 작업이 테스트의 목적과 조건을 달성할 수 있도록 도와주는 과정

	계획 / 제어		- 목표 달성 위한 계획 수립 / 진행되도록 제어

	분석 / 설계		- 목표 구체화하여 테스트 시나리오와 테스트 케이스 작성

	구현 / 실현		- 테스트 케이스들을 조합하여 테스트 프로시저에 명세
				- 모듈 환경에 적합한 단위 테스트 도구를 이용하여 테스트 수행

	평가			- 테스트가 잘 수행되었는지 평가하고 기록

	완료			- 이후 테스트를 위해 수행 과정과 산출물을 기록 및 저장


개발 지원 도구

통합 개발 환경(IDE : Integrated Development Environment)
: 개발에 필요한 편집기, 컴파일러, 디버거 등의 다양한 툴을 하나의 인터페이스로 통합하여 제공
	- Eclipse, Visual Studio, Xcode, Android Studio, IDEA 등
	[설명] Eclipse와 Visual Studio는 대표적인 통합 개발 환경으로 Java, C, 파이썬 등의 언어들로
	개발이 가능하며, Xcode는 애플의 개발 환경으로 대표적인 IOS 개발 환경, Android Studio는
	여러분들의 핸드폰 어플을 개발하는 개발환경이다. 참고로 어떤 개발 환경을 쓰는지는 현업에 가서
	본인이 무슨 일을 하느냐에 따라 달라질 것이며, 현재로서는 Visual Studio Code가 점유율이 가장 높다.

빌드 도구
: 소스 코드 파일들을 컴퓨터에서 실행할 수 있는 제품 소프트웨어로 변환하는 과정 또는 결과물
	- 소스 코드를 소프트웨어로 변환하는 과정에 필요한 전처리, 컴파일 등의 작업을 수행
		ㄱ. Ant
		: 자바 프로젝트의 공식적인 빌드 도구
		ㄴ. Maven
		: Ant의 대안으로 의존성을 설정하여 라이브러리 관리
		ㄷ. Gradle
		: 안드로이드 스튜디오의 공식 빌드 도구

협업 도구
: 개발에 참여하는 사람들이 서로 다른 작업 환경에서 프로젝트를 수행할 수 있도록 도와주는 도구
	- 협업 소프트웨어, 그룹웨어라고도 함

협업 도구의 종류
	ㄱ. 프로젝트 및 일정 관리
	: 구글 캘린더, 분더리스트, 트렐, 지라, 플로우 등
	ㄴ. 정보 공유 및 커뮤니케이션
	: 슬랙, 잔디, 태스크 월드 등
	ㄷ. 디자인
	: 스케치, 제플린 등
	ㄹ. 아이디어 공유
	: 에버노트 등
	ㅁ. API 문서화
	: 스웨거 등
	ㅂ. Git 웹 호스팅 서비스
	: 깃허브 등


소프트웨어 패키징
: 모듈별로 생성한 실행 파일을 묶어 배포용 설치 파일을 만드는 것
	- 사용자 중심으로 진행
	- 모듈화 하여 일반 배포 형태로 패키징

패키징 시 고려사항
	- 사용자의 운영체제, CPU, 메모리 등에 필요한 최소 환경 정의
	- UI는 시각적인 자료와 함께 매뉴얼과 일치시켜 패키징
	- 소프트웨어는 하드웨어와 함께 관리될 수 있도록 Managed Service 형태로 제공
	- 반드시 내부 콘텐츠에 대한 암호화 및 보안을 고려
	- 제품 소프트웨어 종류에 적합한 암호화 알고리즘을 적용

패키징 작업 순서
	- 기능 식별 -> 모듈화 -> 빌드 -> 사용자 환경 분석 ->
	  패키징 및 적용 시험 -> 패키징 변경 및 개선 -> 배포


릴리즈 노트 작성

릴리즈 노트(Release Note) (배포 노트 정도로 생각하면 됨)
: 개발 과정에서 정의된 릴리즈 정보를 고객에게 공유하기 위한 문서
  테스트 진행 방법에 대한 결과와 소프트 웨어 사양에 대한 개발팀의
  정확한 준수 여부 파악
	- 소프트웨어의 버전 관리 및 릴리즈 정보를 체계적으로 관리
	- 소프트웨어 초기 배포, 출시 후 개선 사항을 적용한 추가 배포 시 제공

릴리즈 노트 초기 버전 작성 시 고려사항
	- 정확하고 완전한 정보를 기반으로 개발팀에서 직접 현재 시제로 작성
	- 신규 코드, 빌드 등의 이력이 정확하게 관리되어 변경 또는 개선된 항목에 대한
	  이력 정보들도 작성

릴리즈 노트 추가 버전 작성 시 고려사항
	- 테스트 과정에서 베타 버전이 출시되거나 긴급 버그 수정, 업그레이드, 사용자 요청 등의
	  특수한 상황의 경우 작성
	- 긴급 버그 수정 시 수정하는 경우 릴리즈 버전을 출시하고 그 번호를 포함한
	  모든 내용을 수정된 내용을 담음
	- 요구사항에 의해 추가 혹은 수정된 경우 자체 기능 향상과는 다른 별도의 릴리즈 버전으로
	  출시하고 작성


디지털 저작권 관리

저작권
: 창작자가 가지는 배타적 독점적 권리로 타인의 침해를 받지 않을 고유한 권한
	- 컴퓨터 프로그램처럼 복제하기 쉬운 저작물에 대해 저작권을
	  보호하는 방법을 저작권 보호 기술이라 함

디지털 저작권 관리(Digital Right Management)
: 저작권자가 배포한 디지털 콘텐츠가 저작권자가 의도한 용도로만 사용 되도록
  생성, 유통, 이용까지 전 과정에 걸쳐 사용되는 디지털 콘텐츠 관리 및 보호 기술
	- 크기가 작은 경우 사용자가 콘텐츠를 요청하는 시점에 실시간 패키징 수행
	- 크기가 큰 경우 미리 패키징을 수행 후 배포
	- 종량제 방식을 적용한 소프트웨어의 경우 서비스의 실제 사용량을 측정하여
	  이용한 만큼 이용 부과

디지털 저작권 관리의 흐름도
	ㄱ. 클리어링 하우스(Clearing House)
	: 저작권에 대한 사용 권한, 라이선스 발급, 사용량에 따른 결제 관리 등 수행
	ㄴ. 콘텐츠 제공자(Contents Provider)
	: 콘텐츠를 제공하는 저작권자
	ㄷ. 패키저(Packager)
	: 콘텐츠를 메타 데이터와 함께 배포 가능한 형태로 묶어 암호화 하는 프로그램
	ㄹ. 콘텐츠 분배자(Contents Distributor)
	: 암호화된 콘텐츠를 유통하는 사람
	ㅁ. 콘텐츠 소비자(Customer)
	: 콘텐츠를 구매해서 사용하는 주체
	ㅂ. DRM 컨트롤러(DRM Controller)
	: 배포된 콘텐츠의 이용 권한을 통제하는 프로그램
	ㅅ. 보안 컨테이너(Security Container)
	: 콘텐츠 원본을 안전하게 유통하기 위한 전자적 보안 장치

디지털 저작권 관리의 기술 요소

	구성 요소		설명
	암호화		콘텐츠 및 라이선스를 암호화하고 전자 서명을 할 수 있는 기술

	키 관리		콘텐츠를 암호화한 키에 대하여 저장 및 분배하는 기술

	암호화		콘텐츠를 암호화된 콘텐츠로 생성하기 위한 기술
	파일 생성

	식별 기술		콘텐츠에 대한 식별 체계 표현 기술

	저작권 표현	라이선스의 내용 표현 기술

	정책 관리		라이선스 발급 및 사용에 대한 정책 표현 및 관리 기술

	크랙 방지		크랙에 의한 콘텐츠 사용 방지 기술

	인증		라이선스 발급 및 사용의 기준이 되는 사용자 인증 기술
*크랙
: 영어로 '깨다'라는 의미를 가지고 있는데, 불법적으로 저작권 없이 얻어낸 파일들을 크랙 파일이라고 함
[설명] 어도비나 한글, MS 쪽에서 이 크랙 파일들 때문에 꽤나 많은 골머리를 썩고 있습니다.
거의 매해 보안 업데이트를 하지만 항상 한 달도 못가서 해커들에게 뚫리거든요.
(지키는 화이트 해커쪽 보다는 뚫는 블랙 해커들이 훨씬 유리하기 때문)


소프트웨어 설치 매뉴얼
: 개발 초기에서부터 적용된 기준이나 사용자가 소프트웨어를 설치하는 과정에
  필요한 내용을 기록한 문서
	- 설치 시작부터 완료까지의 과정을 순서대로 설명
	- 설치 과정에서 표시될 수 있는 예외 상황에 관련 내용을 별도로 구분하여 설명
	- 설치 매뉴얼에는 목차, 개요, 기본 사항 등이 기본적으로 포함되어야 함
		ㄱ. 소프트웨어 개요
		: 소프트웨어 주요 기능 및 UI 설명
		ㄴ. 설치 관련 파일
		: 소프트웨어 설치에 필요한 파일 설명
		ㄷ. 설치 아이콘
		: 소프트웨어 설치에 필요한 아이콘 설명
		ㄹ. 프로그램 삭제
		: 설치한 소프트웨어의 삭제 방법 설명
		ㅁ. 관련 추가 정보 설명
		: 소프트웨어 이외의 관련 설치 프로그램, 제작사 등의 추가 정보 설명

설치 매뉴얼 작성
	- 사용자가 설치 과정을 이해하기 쉽게 설치 화면을 누락 없이 캡처하여 순서대로 설명
	- 설치 화면 및 UI, 설치 이상 메시지, 설치 완료 및 결과, 설치 시 점검사항,
	  Network 환경 및 보안, 고객 지원 방법, FAQ, 준수 정보 &제한 보증에 대해 기술


소프트웨어 사용자 매뉴얼
: 사용자가 소프트웨어를 사용하는 과정에서 필요한 내용을 기록한 문서
	- 서문과 기본사항으로 구성됨

사용자 매뉴얼 작성 순서
: 작성 지침 정의 -> 사용자 매뉴얼 구성 요소 정의 -> 구성 요소별 내용 작성 -> 사용자 매뉴얼 검토


소프트웨어 버전 등록

소프트웨어 패키징 형상 관리
: 형상관리는 소프트웨어의 변경 사항을 관리하기 위한 활동
*형상관리 : 프로그램의 버전 관리라고 생각하면 됨
	- 개발 전 단계에 적용되는 활동
	- 개발 비용을 줄이고, 개발 과정의 여러 방해요인이 최소화 되도록
	  보증하는 것을 목적으로 함
	- 형상 관리 항목에는 프로젝트의 계획, 분석서, 설계서 등도 포함됨
	- 대표적인 형상관리 도구는 Git과 Subersion 등이 있음

형상 관리의 중요성
	- 지속적으로 소프트웨어 변경사항을 체계적으로 관리 및 추적할 수 있음
	- 발견된 버그나 수정 사항을 추적
	- 무절제한 변경 방지
	- 배포본을 효율적으로 관리 가능
	- 여러 명의 개발자가 동시에 개발 가능

형상 관리 기능
	ㄱ. 형상 식별
	: 대상에 이름과 관리 번호를 부여하고 계층 구조로 구분하여 수정 및 추적이
	  용이하도록 하는 작업
	ㄴ. 버전 제어
	: 소프트웨어 유지 보수 과정에서 생성된 다른 버전의 형상 항목을 관리하고
	  특정 절차와 도구를 결합하는 작업
	ㄷ. 형상 통제
	: 식별된 형상 항목에 대한 변경 요구를 검토하여 현재의 기준선이
	  잘 반영될 수 있도록 하는 작업
	ㄹ. 형상 감사
	: 기준선의 무결성을 평가하기 위해 확인, 검증, 검열 과정을 통해 공식적으로
	  승인하는 작업
	ㅁ. 형상 기록
	: 형상의 식별, 통제, 감사 작업의 결과를 기록, 관리하고 보고서를 작업하는 작업
	[설명] 3~4년 전만해도 svn의 사용률이 훨씬 높았다.
	그러나 요즘은 gir이 워낙 대중화되고 유명하다보니 svn보다는 git을 더 많이
	사용하는 추세(채용 공고만 봐도 대부분이 git 경험자이다) 또한 sv은 자체 서버가
	죽으면 아무도 작업을 못하는 불상사가 은근히 자주 발생하는데
	git은 그럴 일이 없다.

소프트웨어 버전 등록 관련 주요 용어
	ㄱ. 저장소(Repository)
	: 최신 버전의 파일들과 변경 내역에 대한 정보들이 저장되어 있는 곳
	ㄴ. 가져오기(Import)
	: 아무것도 없는 저장소에 처음으로 파일 복사
		- 소스 파일과 함께 버전 관리를 위한 파일들도 같이 받아옴
	ㄷ. 체크아웃(Check-Out)
	: 저장소에서 소스 파일, 버전 관리를 위한 파일을 받아옴
	ㄹ. 체크인(Check-In)
	: 체크아웃으로 받아온 파일을 수정 후 저장소에 새로운 버전으로 갱신
	ㅁ. 커밋(Commit)
	: 체크인 수행 시 이전에 갱신된 내용이 있는 경우 충돌을 알리고
	  diff 도구를 이용해 수정한 후 갱신
	*diff 도구
	: 비교 대상이 되는 파일의 소스코드를 비교하며 서로 다른 부분을 찾아 표시해주는 도구
	  (differnt 앞글자를 딴 것)
	ㅂ. 동기화(Update)
	: 저장소에 있는 최신 버전을 동기화


소프트웨어 버전 관리 도구

공유 폴더 방식
: 버전 관리 자료가 로컬 컴퓨터의 공유 폴더에 저장되어 관리되는 방식

클라이언트/서버 방식
: 버전 관리 자료가 서버에 저장되어 관리
	- 서버의 자료를 자신의 PC로 복사하여 작업 후 변경 내용을 서버에 반영
	- 모든 버전 관리는 서버에서 수행
	- 대표적으로 CVS, SVN(subversion) 등이 있음

분산 저장소 방식
: 버전 관리 자료가 하나의 원격 저장소와 분산된 PC의 로컬 저장소에 함께 저장되어 관리
	- 원격 저장소의 자료를 자신의 로컬 저장소로 복사하여 작업 후 변경 내용을
	  로컬 저장소에서 버전 관리 후 이를 원격 저장소에 반영
	- 로컬 저장소에서 버전 관리가 가능하므로 원격 저장소에 문제가 생겨도
	  로컬 저장소의 자료를 이용하여 작업할 수 있음
	- 대표적으로 Git, TeamWare 등이 있음

Subversion(SVN)
	- 아파치 소프트웨어 재단에서 2000년에 발표
	- 클라이언트/서버 방식
	- 모든 작업은 trunk 디렉터리에서 추가 작업은 branches 디렉터리 안에
	  별도의 디렉터리를 만들어 작업 후 trunk 디렉터리와 병합
	- 커밋 시 커밋의 버전인 리버전이 1씩 증가
	- 서버는 주로 유닉스/리눅스에서 사용
	- 오픈 소스임
	[설명] trunk의 의미는 '몸통', '줄기'라는 의미이며 branches의 의미는
	'나뭇가지', '부분'이라는 의미를 가지고 있습니다. 이걸 형상관리 도구에
	그대로 적용하면 trunk 디렉터리는 개발 시 가장 중심이 되는 메인 디렉터리이며,
	branches 디렉터리는 trunk 디렉터리에서 나뭇가지처럼 뻗어 나온 trunk 디렉터리를
	기반으로 하고 있지만 변형되었거나 변형하기 위해서 작업 중인 다른 디렉터리라고
	생각하면 됩니다.

Subversion(SVN)명령어
ㄱ. add
: 새로운 파일이나 디렉토리를 관리 대상으로 지정
ㄴ. commit
: add한 소스파일을 서버의 소스파일에 적용
ㄷ. update
: 서버의 최신 commit 이력을 클라이언트 소스에 적용
ㄹ. checkout
: 서버에서 버전 관리 정보와 소스 파일을 받아옴
ㅁ. import
: 아무것도 없는 서버의 저장소에 맨 처음 소스 파일을 저장
ㅂ. export
: 버전 관리 정보 빼고 소스 파일만 서버에서 받아옴
ㅅ. info
: 지정된 파일에 대한 정보를 표시
ㅇ. diff
: 지정된 파일이나 경로에 대해 이전 리버전과의 차이를 표시
ㅈ. merge
: 다른 디렉터리에서 작업 된 버전 관리 내역을 기본 개발 작업과 병함

			SVN
			중앙 서버
			Version 1
			Version 2
			Version 3

	Check-out↓↑Check-In	Check-in↑↓Check-out

	     클라이언트 PC		     클라이언트 PC
		A			B
		      [Svn 버전 관리 구조]

Git
	- 리누스 토발즈가 2005년에 개발
	- 분산 저장소 방식
	- 버전 관리가 지역 저장소에서 진행되어 버전 관리가 신속하게 처리되고,
	  원격 저장소나 네트워크에 문제가 있어도 작업 가능
	- 브런치를 이용하여 기본 버전 관리 틀에 영향을 주지 않으면서
	  다양한 형태의 테스팅 가능
	- 파일의 변화를 스냅샷으로 저장하고 이전 스냅샷의 포인터를 가져
	  버전의 흐름 파악 가능
	*스냅샷
	: 영문자와 숫자가 혼합된 40자리 문자열
	*포인터
	: 접근하고자 하는 데이터가 저장되어 있는 위치 정보

Git 명령어
ㄱ. add
: 작업 내역을 스테이징 영역에 추가하여 버전 관리 대상으로 지정
ㄴ. commit
: 작업 내역을 지역 저장소에 저장
ㄷ. branch
: 새로운 브런치 생성 / 삭제
ㄹ. chekcout
: 지정한 브런치로 이동
ㅁ. mergy
: 두 브런치 병합
ㅂ. init
: 지역 저장소 생성
ㅅ. remote add
: 원격 저장소에 연결
ㅇ. push
: 로컬 저장소의 변경 내용을 원격 저장소에 반영
ㅈ. fetch
: 원격 저장소의 변경 이력만 지역 저장소에 반영
ㅊ. clone
: 원격 저장소의 전체 내용을 지역 저장소로 복제
ㅋ. fork
: 지정한 원격 저장소의 내용을 자신의 원격 저장소로 복제

			원격 저장소
			Version 1
			Version 2
			Version 3

	Fetch/Clone↓↑Push	Push↑↓Fetch/Clone

	      로컬 저장소 A		   로컬 저장소 B
	      Version 1		   Version 1
	      Version 2		   Version 2
	      Version 3		   Version 3
[설명] git과 svn 명령어는 다 외워야 하나요?
어느 정도는 숙지하실 필요가 있습니다.
사실 실무에서는 자주 쓰는 명령어가 아니라면 그냥 검색해서 사용합니다.
왜냐하면 요즘 IT 트랜드 자체가 구글링을 해서 짧은 시간 안에 학습한 후
실무에 적용할 수 있는 것을 능력으로 보는 시대거든요.
다만! 시험을 위해서는 위에 있는 것들 정도는 숙지하고 있을 필요성은 있습니다.


빌드 자동화 도구
: 소스 코드를 컴파일한 후 여러 개의 모듈로 묶어 실행 파일로 만드는 과정을
  포함하여 테스트 및 배포를 자동화하는 도구

Jenkins(젠킨스)
: Java 기반 오픈 소스 형태의 빌드 자동화 도구
	- 서블릿 컨테이너에서 실행되는 서버 기반 도구
	*서블릿 컨테이너
	: 클라이언트의 요청을 처리해 주기 위해 서버측에서 실행되는 프로그램인
	  서블릿을 실행하고 서블릿의 생명주기를 관리하는 역할
	*서블릿(Servlet)
	: 클라이언트의 요청을 처리하고, 그 결과를 반환하는 Servlet 클래스의
	  구현 규칙을 지킨 자바 웹 프로그래밍 기술
	- 형상 관리 도구와 연동 가능
	- Web GUI 제공으로 사용이 쉬움
	- 여러 대의 컴퓨터를 이용한 분산 빌드나 테스트 가능

Gradle(그레이들)
: Groovy를 기반으로 한 오픈 소스 형태의 자동화 도구
*Groovy
: 아파치의 자바 가상 머신에서 작동하는 동적 타이핑 프로그래밍 언어로
  객체 지향 프로그래밍 언어 중 하나
	- 안드로이드 앱 개발 환경에 사용
	- Java, C/C++, Python 등의 언어도 빌드 가능
	- Groovy를 사용해서 만든 DSL을 스크립트 언어로 사용
	*DSL(Domain-specific language)
	: 웹페이지 영역에 특화되어 사용되는 HTML과 같이 특정한 도메인
	  (산업 분야 등의 특정 영역)에 특화된 언어를 말함
	- 실행할 처리 명령들을 모아 태스크로 만든 후 태스크 단위로 실행
	- 이전 태스크를 재사용하거나 다른 시스템의 태스크를 공유하여
	  빌드의 속도를 향상시킬 수 있음


애플리케이션 테스트
: 애플리케이션에 잠재된 결함을 찾아내는 과정
	- 확인(Validation) : 개발된 소프트웨어가 요구사항을 만족시키는지
	  사용자의 입장에서 확인
	- 검증(Verification) : 기능을 제대로 수행하고 명세서에 맞게
	  만들었는지 개발자의 입장에서 점검
	- 테스트 전 개발한 소프트웨어의 유형을 분류하고 특성을 정리해서
	  중점적으로 테스트할 사항을 정리

애플리케이션 테스트의 필요성
	- 미리 오류를 발견하고 새로운 오류의 유입 예방
	- 사용자의 요구사항에 만족하는지 테스트해 제품의 신뢰도 향상

애플리케이션 테스트의 기본 원리
	- 잠재적인 결함을 줄일 수 있지만 소프트웨어 자체 결함이 없다곤 할 수 없음
	- 결함은 특정 모듈에 집중되어 있어 애플리케이션의 20%에 해당하는 코드에서
	  80%의 결함이 발견된다고 하여 파레토의 법칙을 적용하기도 함
	*파레토의 법칙(Pareto Principle)
	: 전체 결과 80%가 전체 원인 20%에서 일어나는 현상
	- 살충제 패러독스 현상을 방지하기 위해 테스트 케이스를 지속적으로 보완 및 개선
	*살충제 패러독스(Pesticide Paradox)
	: 살충제를 지속적으로 뿌리면 벌레가 내성이 생겨 죽지 않는 현상으로 이를 애플리케이션
	  테스트에 적용하면 똑같은 테스트 케이스를 통해서 테스트를 했을 시 더이상의 오류가
	  발생되지 않는 현상을 말함
	- 테스트와 위험은 반비례함
	- 테스트는 개발자와 관계없는 팀에서 별도로 수행해야 함
	- 테스트를 정황에 따라 다르게 진행
	- 작은 부분에서 시작해서 점점 확대하며 진행
	- 결함을 모두 제거해도 사용자의 요구사항을 만족시키지 못하면 해당 소프트웨어는
	  품질이 높다고 할 수 없음(오류-부재의 궤변 이라고도 함)


애플리케이션 테스트 분류

프로그램 실행 여부
ㄱ. 정적 테스트
: 프로그램을 실행하지 않고 소스코드나 명세서를 분석하여 테스트
	- 개발 초기에 결함을 발견할 수 있어 비용을 절감
	- 워크 스루, 인스펙션, 코드 검사 등이 있음
	*워크 스루(Walkthrough)
	: 소프트웨어 개발자의 작업 내역을 개발자가 모집한 전문가들이 검토하는 것
	*인스펙션(Inspection)
	: 워크스루의 발전 형태로 소프트웨어 개발 단계에서 산출된 결과물이
	  품질을 평가하며 이를 개선하기 위한 방법 제시
ㄴ. 동적 테스트
: 프로그램을 실행하여 테스트
	- 개발의 모든 단계에서 실행
	- 블랙박스 테스트, 화이트 박스 테스트

테스트 기반에 따른 테스트
: 테스트 시 무엇을 기반으로 수행하느냐에 따라 명세/구조/경험 기반 테스트로 분류됨
	ㄱ. 명세 기반 테스트
	: 사용자의 요구사항을 테스트 케이스로 만들어 구현하고 있는지 확인하여 테스트
		- 동등 분할, 경계 값 분석
	ㄴ. 구조 기반 테스트
	: 소프트웨어 내부 논리 흐름에 따라 테스트 케이스를 만들어 테스트
		- 구문 기반, 결정 기반, 조건 기반 등
	ㄷ. 경험 기반 테스트
	: 테스터의 경험을 기반으로 테스트
		- 요구사항에 대한 명세가 부족하거나 시간의 제약이 있는 경우
		- 에러 추정, 체크 리스트, 탐색적 테스팅

시각에 따른 테스트
: 테스트를 할 때 누구를 기준으로 하느냐에 따른 테스트
	ㄱ. 확인 테스트(Validation)
	: 사용자의 시각에서 결과를 테스트
		- 요구사항을 만족하면서 정상적으로 동작이 되는지 테스트
	ㄴ. 검증 테스트(Verification)
	: 개발자의 시각에서 과정을 테스트
		- 명세서에 맞게 완성되었는지 테스트

목적에 따른 테스트
ㄱ. 회복 테스트(Recovery Test)
: 결함을 주고 잘 복구되는지 테스트
ㄴ. 안전 테스트(Security Test)
: 시스템 보호 도구가 불법적인 침입으로부터 보호할 수 있는지 테스트
ㄷ. 강도 테스트(Stress Test)
: 과부하 시 정상적으로 실행되는지 테스트
ㄹ. 성능 테스트(Performance Test)
: 응답 시간, 처리량 등을 테스트
ㅁ. 구조 테스트(Structure Test)
: 내부의 논리적인 경로, 소스 코드 복잡도 등을 평가
ㅂ. 회귀 테스트(Regression Test)
: 변경 혹은 수정에 따른 새로운 결함이 없는지를 테스트
ㅅ. 병행 테스트(Parallel Test)
: 기존의 소프트웨어와 변경된 소프트웨어에 동일한 데이터를 입력하여
  결과를 비교하는 테스트


테스트 기법

화이트박스 테스트
: 모듈의 원시 코드를 오픈하여 논리적인 모든 경로를 한번 이상 실행하면서
  테스트하여 테스트 케이스를 설계
	- 테스트 과정의 초기에 진행
	- 설계된 절차에 초점을 둔 구조적 테스트
	- 모듈 안의 동작을 직접 관찰
	- 프로그램을 제어 구조에 따라 선택, 반복 등의 분기점 부분들을
	  수행함으로써 논리적 경로 제어

화이트박스 테스트의 종류
ㄱ. 기초 경로 검사(Base Path Testing)
: 테스트 케이스 설계자가 절차적 설계의 논리적 복잡성을 측정할 수 있게
  해주는 대표적인 화이트박스 테스트 기법
	- 테스트 측정 결과를 통해 실행 경로의 기초를 정의
ㄴ. 제어 구조 검사(Control Structure Testing)
	a. 조건 검사(Condition Testing)
	: 프로그램 내의 논리적 조건을 테스트
	b. 루프 검사(Loop Testing)
	: 프로그램 내의 반복 구조에 초점을 맞춰 테스트
	c. 데이터 흐름 검사(Data Flow Testing)
	: 프로그램 내의 변수의 정의와 사용의 위치에 초점을 맞춰 테스트

화이트박스 테스트 검증 기준
: 테스트 케이스들이 테스트에 얼마나 적합한지 판단하는 기준
	ㄱ. 문장 검증 기준
	: 소스 코드의 모든 구문이 한 번 이상 수행되도록 설계
	ㄴ. 분기 검증 기준
	: 소스 코드의 모든 조건문이 한 번 이상 수행되도록 설계
	ㄷ. 조건 검증 기준
	: 소스 코드의 모든 조건문에 대해 참/거짓인 경우가 한 번 이상
	  수행되도록 설계
	ㄹ. 분기/조건 기준
	: 모든 조건문과 조건문에 포함된 개별 조건식의 결과가 참/거짓인
	  경우가 한 번 이상 수행되도록 설계

블랙박스 테스트
: 소프트웨어가 수행할 특정 기능을 알기 위해 기능이 완전히 작동되는 것을
  입장하는 기능 테스트
	- 테스트 과정의 후반부에 진행
	- 사용자의 요구사항 명세를 보면서 구현된 기능을 테스트
	- 소프트웨어 인터페이스에서 실시

블랙박스 테스트의 종류
ㄱ. 동치(동등) 분할 검사(Equivalence Partitioning Testing)
: 입력 자료에 초점을 맞춰 테스트 케이스를 만들고 검사
	- 프로그램 입력 조건에 타당한 입력 자료와 타당하지 않은 입력 자료의
	  개수를 균등하게 하여 테스트 케이스를 정하고, 해당 입력 자료에 맞는
	  결과가 출력되는지 확인
ㄴ. 경계값 분석(Boundary Value Analysis)
: 입력 자료에만 치중된 동치 분할 기법을 보완하기 위한 기법
	- 입력 조건의 중간값보다 경계값에서 오류가 발생될 확률이 높다는 점을
	  이용하여 입력 조건의 경계값을 테스트 케이스로 선정하여 검사하는 기법
ㄷ. 원인-효과 그래프 검사(Cause-Effect Graphing Testing)
: 입력 데이터 간의 관계와 출력에 영향을 미치는 상황을 분석 후
  효용성이 높은 테스트 케이스를 선정하여 검사

ㄹ. 오류 예측 검사(Error Guessing)
: 과거 경험이나 확인자의 감각으로 테스트
	- 보충적 검사 기법이며, 데이터 확인 검사라고도 함
ㅁ. 비교 검사(Comparison Testing)
: 여러 프로그램에 동일한 테스트 자료를 제공하여 동일한 출력이
  나오는지 확인하는 검사


개발 단계에 따른 어플리케이션 테스트
: 소프트웨어 개발 단계에 따라 단위 테스트, 통합 테스트, 시스템 테스트, 인수 테스트로
  분류되며 이렇게 분류된 것을 테스트 레벨이라고 함

요구사항							인수 테스트	
(Requirements)						(Acceptance Testing)
	분석					시스템 테스트
	(Specification)				(System Testing)
		설계			통합 테스트
		(Design)			(Integration Testing)
			구현	단위테스트
			(Code)	(Unit Testing)
	[소프트웨어				[테스트 단계]
	 개발단계]
			[소프트웨어 생명 주기 V 모델]

단위 테스트(Unit Test)
: 코딩 직후 모듈이나 컴포넌트에 초점을 맞춰 하는 테스트
	- 인터페이스, 외부적 I/O, 자료 구조 등을 검사
	- 사용자 요구사항을 기반으로 한 기능성 테스트를
	  최우선으로 수행
	- 구조 기반 테스트와 명세 기반 테스트로 나뉘며 주로
	  구조 기반 테스트로 시행
		ㄱ. 구조 기반 테스트
		: 프로그램 내부 구조 및 복잡도를 검증하는 화이트박스 테스트를
		  시행하여 제어 흐름이나 조건 결정을 목적으로 함
		ㄴ. 명세 기반 테스트
		: 목적 및 실행 코드 기반의 블랙 박스 테스트를 시행하여
		  동등 분할이나 경계값 분석을 목적으로 함

통합 테스트(Intergration Test)
: 단위 테스트가 완료된 모듈들을 결합하여 하나의 시스템으로
  완성하는 과정에서 테스트
	- 모듈 간 또는 통합된 컴포넌트 간 상호 작용 오류 검사
		ㄱ. 비점진적 통합 방식
		: 모든 모듈이 미리 결합되어 있는 프로그램 전체를 테스트
			- 빅뱅 통합 테스트 방식
			*빅뱅 통합 테스트
			: 모듈 간의 상호 인터페이스를 고려하지 않고 단위 테스트가 끝난 모듈을
			  한꺼번에 결합시켜 테스트하는 방법
			- 오류 발견 및 장애 위치 파악이 어려움
		ㄴ. 점진적 통합 방식
		: 모듈 단위로 단계적으로 통합하면서 테스트
			- 하향식, 상향식, 혼합식 테스트 방식이 있음
			- 오류 수정이 용이하고 인터페이스 관련 오류를
			  완전히 테스트 할 수 있음
				a. 하향식 통합 테스트
				: 상위 모듈에서 하위 모듈 방향으로 통합하면서 테스트
					- 깊이 우선 통합법이나 넓이 우선 통합법 사용
					- 상위 모듈에선 테스트 케이스 사용이 어려움
					- 테스트 초기부터 사용자에게 시스템 구조를 보여 줄 수 있음
					- 주요 제어 모듈은 작성된 프로그램을 사용하고, 주요 제어 모듈의
					  종속 모듈은 스텁으로 대체함
					*스텁(Stub)
					: 제어 모듈이 호출하는 타 모듈의 기능을 단순히 수행하는 도구
				b. 상향식 통합 테스트
				: 하위 모듈에서 상위 모듈 방향으로 통합하면서 테스트
					- 하나의 주요 제어 모듈과 종속 모듈의 그룹인 클러스터가 필요
					- 하위 모듈 클러스터로 결합 -> 상위 모듈 입출력 확인을 위해
					  더미 모듈인 드라이버 작성 -> 통합된 클러스터 단위로 테스트
					  -> 완료 후 클러스터는 프로그램 구조 상위로 이동, 드라이버는
					  실제 모듈로 대체
					*드라이버
					: 테스트 대상의 하위 모듈을 호출, 파라미터 값 전달, 모듈 테스트 수행
					  후의 결과를 도출하는 도구
				[설명] 테스트 드라이버와 스텁의 차이
				드라이버는 이미 존재하는 하위 모듈과 존재하지 않는 상위 모듈 간의 인터페이스
				역할을 하며 개발이 완료되면 드라이버는 본래의 모듈로 교체됩니다.
				반면, 스텁은 일시적으로 필요한 조건들만 가지고 '임시'로 제공되는 가짜 모듈의
				역할입니다. 한 마디로 '시험용 모듈'이기에 드라이버보다 작성하기가 훨씬 쉽습니다.
				c. 혼합식 통합 테스트
				: 하위 수준에서는 상향식 통합 상위 수준에서는 하향식 통합을 사용하여
				  최적의 테스트를 지원하며 샌드위치 통합 테스트 방법이라고도 함
				d. 회귀 테스트
				: 이미 테스트된 프로그램의 테스트를 반복
					- 통합 테스트로 변경된 모듈이나 컴포넌트에 새로운 오류가 있는지 확인


테스트 케이브 | 시나리오 | 오라클

테스트 케이스
: 사용자의 요구사항이 준수되었는지 확인하기 위해 테스트 항목에 대하여
  명세 기반 테스트의 설계 산출물
*명세 기반 테스트
: 사용자의 요구 사항에 대한 명세를 빠짐없이 테스트 케이스로 구현하고 있는지를
  명시하여 확인하는 것
	- 테스트 케이스 작성 순서는 아래와 같음

	1단계		- 테스트 계획 검토 및 자료 확보
				↓
	2단계		- 위험 평가 및 우선순위 결정
				↓
	3단계		- 테스트 요구사항 정의
				↓
	4단계		- 테스트 구조 설계 및 테스트 방법 결정
				↓
	5단계		- 테스트 케이스 정의
				↓
	6단계		- 테스트 케이스 타당성 확인 및 유지보수

테스트 시나리오
: 테스트 케이스를 적용하는 구체적인 절차를 명세한 문서

테스트 오라클
: 테스트 결과가 올바른지 판단하기 위해 정의된 참 값을 대입하여
  비교하는 기법
	ㄱ. 제한된 검증
	: 모든 테스트 케이스에는 적용 불가
	ㄴ. 수학적 기법
	: 수학적 기법을 통해 테스트 오라클 값을 구할 수 있음
	ㄷ. 자동화 기능
	: 테스트 대상에 대한 실행, 결과 비교 등을 자동화할 수 있음

테스트 오라클의 종류
ㄱ. 참 오라클
: 모든 테스트 케이스의 입력 값에 대해 기대하는 결과를 제공
ㄴ. 샘플링 오라클
: 특정 테스트 케이스의 입력 값에 대해 기대하는 결과를 제공
ㄷ. 추정 오라클
: 특정 테스트 케이스의 입력 값에 대해 기대하는 결과를 제공하고
  나머지 값에 대해서는 추정으로 처리
ㄹ. 일관성 검사 오라클
: 변경 시 테스트 케이스 수행 전과 후의 결과 값이 동일한지 확인


테스트 자동화 도구

테스트 자동화
: 반복적인 테스트 절차를 스크립트 형태로 구현하는 자동화 도구를 적용하여
  쉽고 효율적으로 테스트 수행

테스트 자동화 도구의 장단점
ㄱ. 장점
	- 반복적인 작업을 자동화해 인력 및 시간 절감
	- 향상된 테스트 품질 보장
	- 사용자의 요구사항 등을 일관성 있게 검증
	- 테스트 결과에 대한 객관적인 평가 기준 제공
	- 테스트 결과를 다양한 표시 형태로 제공
	- UI가 없는 서비스도 정밀 테스트 가능
ㄴ. 단점
	- 사용방법에 대한 교육 및 학습 필요
	- 자동화 도구를 프로세스 단계별로 적용하기 위한
	  시간, 비용, 노력이 필요

테스트 자동화 도구의 유형
ㄱ. 정적 분석 도구(Static Analysis Tools)
: 프로그램을 실행하지 않고 소스코드를 통해 결함을 발견
ㄴ. 테스트 케이스 생성 도구(Test Case Generation Tools)
: 자료 흐름도, 기능 테스트, 입력 도메인 분석, 랜덤 테스트 등이 있음
ㄷ. 테스트 실행 도구(Test Execution Tools)
: 스크립트 언어를 사용하여 테스트를 실행하는 방법
ㄹ. 성능 테스트 도구(Performance Test Tools)
: 가상의 사용자를 만들어 테스트를 수행
ㅁ. 테스트 통제 도구(Test Control Tools)
: 테스트 계획 및 관리, 수행, 결함 관리 등을 수행
ㅂ. 테스트 하네스 도구(Test Harness Tools)
: 애플리케이션 컴포넌트 및 모듈을 테스트하는 환경의 일부분으로
  테스트를 지원하기 위해 생성된 코드와 데이터를 의미하며, 테스트가
  실행될 환경을 시뮬레이션하여 컴포넌트 및 모듈이 정상적으로
  테스트되도록 함
[설명]
테스트 하네스의 구성요소는 테스트 드라이버, 테스트 스텁, 테스트 슈트,
테스트 케이스, 테스트 스크립트, 목 오브젝트 등이 있으나 필기에서는
이렇게 상세하게까지 알 필요 없이 종류만 알고 있으면 됨

테스트 수행 단계별 테스트 자동화 도구
ㄱ. 테스트 계획 단계
: 요구사항 관리 도구
ㄴ. 테스트 분석 및 설계 단계
: 테스트 케이스 생성 도구
ㄷ. 테스트 수행 단계
: 테스트 자동화 / 정적 분석 / 동적 분석 / 성능 테스트 / 모니터링 요구
ㄹ. 테스트 관리 단계
: 커버리지 분석 / 형상 관리 / 결함 추적 및 관리 도구


결함
: 소프트웨어가 개발자가 설계한 것과 다르게 동작하거나 다른 결과가 발생하는 것

결함 관리 프로세스
: 애플리케이션 테스트에서 발견된 결함을 처리

	결함 관리 계획 -> 결함 기록 -> 결함 검토 -> 결함 수정 -> 결함 재확인 -> 최종 결함 분석 및 보고서 작성

						↓
					     결함 관리 DB
					[결함 상태 추적 및 모니터링 활동]

결함 상태 추적
: 테스트에서 발견된 결함은 지속적으로 상태 변화를 추적하고 관리해야 함
	- 결함 분포 : 모듈의 특정 속성에 해당하는 결함 수 측정
	- 결함 추세 : 테스트 지속 시간에 따른 결함 수의 추이 분석
	- 결함 에이징 : 결함 상태로 지속되는 시간 측정

결함 추적 순서
: 결함이 발견되고 해결될 때까지의 과정
	등록 -> 검토 -> 할당 -> 수정 -> 조치 보류 -> 해제

결함 분류
ㄱ. 시스템 결함
: 주로 애플리케이션이나 데이터베이스 처리에서 발생된 결함
ㄴ. 기능 결함
: 애플리케이션의 기획, 설계, 업무 시나리오 등의 단계에서 유입된 결함
ㄷ. GUI 결함
: 화면 설계에서 발생된 결함
ㄹ. 문서 결함
: 기획자, 사용자, 개발자 간 의사소통 및 기록이 원활하지 않아 발생된 결함

결함 심각도
: 결함이 전체 시스템에 미치는 치명도를 High, Medium, Low로 나눈 것

결함 관리 도구
	- Mantis : 소프트웨어 설계 시 단위 별 작업 내용을 기록할 수 있어
	  결함 및 이슈 관리, 추적 도구
	- Trac : 결함 추적 및 통합 관리 도구
	- Redmine : 프로젝트 관리 및 결함 추적 도구
	- Bugzilla : 결함을 지속적으로 관리하고 심각도와 우선순위를 지정할 수 있는 도구


애플리케이션 성능
: 사용자가 요구한 기능을 최소환의 자원을 사용하여 최대한 많은 기능을
  신속하게 처리하는 정도
	- 측정 지표 : 처리량, 응답 시간, 경과 시간, 자원 사용률

성능 테스트 도구
: 애플리케이션의 성능을 테스트하기 위해 부하나 스트레스를 가해
  성능 측정 지표를 점검하는 도구
	- JMeter : 다양한 프로토콜을 지원하는 부하 테스트 도구
	- LoadUI : 사용자의 편리성이 강화된 부하 테스트 도구
	- OpenSTA : HTTP, HTTPS 프로토콜에 대한 부하 테스트 및 생산품 모니터링 도구

시스템 모니터링 도구
: 애플리케이션 실행 중 시스템 자원의 사용량을 확인하고 분석하는 도구
	- 성능 저하의 원인 / 시스템 부하량 / 사용자 분석과 같은 시스템을
	  안정적으로 운영할 수 있는 기능 제공
	- Scouter, Zabbix 등이 있음


복잡도
: 시스템이나 시스템 구성 요소 또는 소프트웨어의 복잡한 정도를 나타내는 말로,
  시스템 또는 소프트웨어를 어느 정도의 수준까지 테스트해야 하는지 또는 소프트웨어를
  어느 정도의 수준까지 테스트해야 하는지 또는 개발하는데 어느 정도의 자원이 소요되는지
  예측하는데 사용
	- 복잡도가 높으면 장애가 발생할 수 있으므로 정밀한 테스트를 통해
	  미리 오류를 제거할 필요가 있음
	- 복잡도 측정 방법에는 LOC, 순환 복잡도 등이 있음

시간 복잡도
: 알고리즘을 수행하기 위해 프로세스가 수행하는 연산 횟수를 수치화 한 것을 말함
	- 시간 복잡도가 낮을 수록 알고리즘 실행시간이 짧고, 높을수록 실행시간이 길어짐
	- 빅오, 세타, 오메가 표기법이 있음
		ㄱ. 빅오 표기법
		: 알고리즘 실행시간이 최악일 때를 표기하는 방법
			- 신뢰성이 떨어지는 오메가 표기법과 평가하기 까다로운 세타 표기법에
			  비해 성능을 예측하기 용이하여 주로 사용
			- 일반적인 알고리즘에 대한 최악의 시간 복잡도를 빅오 표기법으로
			  표기할 시 아래와 같음

				표기		설명
				O(1)		입력값 n에 관계 없이 일정하게 문제 해결에 하나의 단계만을 거침
						ex) 스택의 삽입, 삭제

				O(log2n)		문제 해결에 필요한 단계가 입력값 또는 조건에 의해 감소
						ex) 이진 트리, 이진 검색

				O(n)		문제 해결에 필요한 단계가 입력값과 1:1의 관계를 가짐
						ex) for문

				O(nlog2n)		문제 해결에 필요한 단계가 O(nlong2n)번만큼 수행
						ex) 힙 정렬, 2-way 합병 정렬

				O(n2)		문제 해결에 필요한 단계가 입력값의 제곱만큼 수행
						ex) 삽입 정렬, 쉘 정렬, 선택 정렬, 버블 정렬, 퀵 정렬

				O(2n)		문제 해결에 필요한 단계가 2의 입력값 제곱만큼 수행
						ex) 피보나치 수열

		ㄴ. 세타 표기법
		: 알고리즘 실행시간이 평균일 때를 표기하는 방법
		ㄷ. 오메가 표기법
		: 알고리즘 실행시간이 최상일 때를 표기하는 방법

순환 복잡도
: 한 프로그램의 논리적인 복잡도를 측정하기 위한 소프트웨어의 척도로,
  맥케이브 순환도 또는 맥케이브 복잡도 라고도 하며, 제어 흐름 이론에 기초를 둠
	- 순환 복잡도를 이용하여 계산된 값은 프로그램의 독립적인 경로의 수를 정의
	- 순환 복잡도를 구하라고 할 시, 순환 복잡도 = 화살표의 수 -노드의 수 +2 를 기억하자


애플리케이션 성능 개선

소스코드 최적화
: 나쁜 코드를 배제하고 클린 코드로 작성
*클린 코드
: 누구나 쉽게 이해하고 수정 및 추가할 수 있도록 깔끔하게 잘 작성된 코드

클린 코드 작성 원칙
ㄱ. 가독성
: 누구든지 쉽게 읽을 수 있도록 작성
ㄴ. 단순성
: 코드를 간단하게 작성
ㄷ. 의존성 배제
: 코드가 다른 모듈에 미치는 영향 최소화
ㄹ. 중복성 최소화
: 코드의 중복을 최소화
ㅁ. 추상화
: 상위 클래스, 메소드, 함수에서 간략하게 애플리케이션 특성을 나타내고,
  상세 구현은 하위 클래스, 메소드, 함수에서 구현

소스 코드 최적화 유형
: 클래스 분할 배치, 느슨한 결합, 코딩 형식 준수, 좋은 이름 사용, 적절한 주석문 사용
*주석문
: 코딩을 할때 // 표기나 ** 표기를 사용하여 코드가 아닌 참고할 수 있는 내용을 작성할 수 있는데,
  한 마디로 다른 사람이 보거나 내가 다시 봤을 때 알아보기 쉽게 표기를 해놔야 한다는 의미

소스 코드 품질 분석 도구
: 소스 코드의 코딩 스타일, 코드에 설정된 코딩 표준, 코드의 복잡도, 코드에 존재하는 메모리 누수 현상,
  스레드 결함 등을 발견하기 위해 사용하는 분석 도구로 정적 분석 도구와 동적 분석 도구로 분류됨
*스레드
: 프로세스 내에서의 작업단위로 시스템의 여러 자원을 할당 받아 실행하는 프로그램의 단위
	ㄱ. 정적 분석 도구
	: 작성한 소스 코드를 실행하지 않고 코딩 표준이나 코딩 스타일, 결함 등을
	  확인하는 코드 분석 도구
		- 소스 코드를 실행하지 않고 분석
		- 코드에 있는 오류나 잠재적인 오류를 찾아내기 위한 활동
		- 자료 흐름이나 논리 흐름을 분석하여 비정상적인 패턴을 찾을 수 있음
		- 애플리케이션 개발 초기의 결함을 찾는데 사용되며, 개발 완료 시점에서는
		  개발된 소스 코드의 품질을 검증하는 차원에서 사용
		- 종류로는 pmd, cppcheck, SonarQube, checkstyle, ccm, cobertura 등이 있음
		  >> 정적 분석도구종류'만' 자주 출제 되므로 종류를 숙지하고 있을 것!
	ㄴ. 동적 분석 도구
	: 작성한 소스 코드를 실행하여 코드에 존재하는 메모리 누수, 스레드 결함 등을 분석하는 도구
		- 종류로는 Avalanche, Valgrind 등이 있음

모듈 간 공통 기능 및 데이터 인터페이스의 개요
	- 공통 기능 : 모듈에 공통적으로 제공되는 기능
	- 데이터 인터페이스 : 모듈 간 교환되는 데이터가 저장될 파라미터
	- 인터페이스 설계서에서 정의한 모듈의 기능을 기반으로 확인

인터페이스 설계서
: 교환 데이터 및 관련 업무, 송수신 시스템 등에 대한 내용을 정리한 문서


모듈 연계를 위한 인터페이스 기능 식별

모듈 연계
: 모듈 간 데이터 교환을 위해 관계를 설정하는 것으로 대표적으로 EAI와 ESB방식이 있음

EAI(Enterprise Application Integration)
: 기업 내 정보 전달, 연계, 통합 등 상호 연동이 가능하게 해주는 솔루션
	ㄱ. Point-to-Point
		- 애플리케이션끼리 1:1로 연결
		- 변경 및 재사용이 어려움
	ㄴ. Hub &Spoke
		- 단일 접점인 허브 시스템을 통해 데이터를 전송하는 중앙 집중형 방식
		- 확장 및 유지보수 용이
		- 허브 장애 시 전체 시스템에 영향
	ㄷ. Message Bus(ESB 방식)
		- 애플리케이션 사이 미들웨어를 두어 처리
		- 확장성이 뛰어나고 대용량 처리 가능
	ㄹ. Hybrid
		- Hub &Spoke와 Message Bus의 혼합 방식
		- 그룹 내에선 Hub &Spoke 방식을 그룹 간에는 Message Bus 방식 이용
		- 데이터 병목 현상 최소화

ESB(Enterprise Service Bus)
: 애플리케이션 간 표준 기반 인터페이스를 제공하는 솔루션

	App		App		App
		↖↘	 ↕	↗↙
	App	↔	ESB	↔	App
		↙↗	 ↕	↘↖
	App		App		App

	- 애플리케이션보다는 서비스 중심의 통합을 지향
	- 애플리케이션과의 결합도를 약하게 유지
	- 관리 및 보안 유지가 쉽고 높은 수준의 품질 지원


인터페이스 구현
: 송수신 시스템 간의 데이터 교환 및 처리를 실현해주는 작업
	- 정의된 인터페이스 기능 구현을 기반으로 인터페이스 구현 방법을
	  분석하고 분석한 인터페이스 구현 정의를 기반으로 구현

데이터 통신을 이용한 인터페이스 구현
: 애플리케이션 영역에서 인터페이스 형식에 맞춘 데이터 포맷을 인터페이스 대상으로
  전송하고 이를 수신하는 측에서 파싱 하여 해석하는 방식
*파싱(Parsing)
: 주어진 문장이 정의된 문법 구조에 따라 완전한 문장으로 사용될 수 있는지를 확인하는 작업
	- JSON, XML 형식 사용
		ㄱ. JSON(Javascript Object Notation)
		: 속성-쌍-값으로 이루어진 데이터 객체를 전달하기 위해 사람이 읽을 수 있는
		  텍스트를 사용하는 개방형 표준 포맷
			- 비동기 처리에 사용되는 AJAX에서 XML을 대체하여 사용되고 있음
		ㄴ. XML(Extensible Markup Language)
		: 특수한 목적을 갖는 마크업 언어를 만드는데 사용되는 다목적 마크업 언어
			- 웹 페이지의 기본 형식인 HTML의 문법이 각 웹 브라우저에서
			  상호 호환적이지 못하다는 문제와 *SGML을 해결하기 위해서 개발
			*SGML(Stand Generalized Markup Language)
			: 텍스트, 이미지, 오디오 및 비디오 등을 포함하는 멀티미디어 전자문서들을
			  다른 기종의 시스템들과 정보의 손실 없이 효율적으로 전송 및 자동 처리하기 위한 언어
		ㄷ. AJAX(Asynchronous Javascript and XML)
		: 자바 스크립트등을 이용하여 클라이언트와 서버 간에 XML 데이터를 교환 및 제어함으로써
		  이용자와 자유롭게 상호 작용할 수 있도록 하는 비동기 통신 기술
		  (웹 화면에서 부분 새로고침 정도로 이해하면 됨)


인터페이스 구현 검증
: 인터페이스가 정상적으로 잘 작동하는지 확인하는 것

인터페이스 구현 검증 도구
: 인터페이스 구현을 검증하기 위해 단위 기능과 시나리오 등을 기반으로 하는 통합 테스트가 필요
	ㄱ. xUnit
	: Java, C++, .Net 등 다양한 언어를 지원하는 단위 테스트 프레임워크
	ㄴ. STAF
	: 서비스 호출 및 컴포넌트 재사용 등 다양한 환경을 지원하는 프레임워크
	ㄷ. FitNesse
	: 웹 기반 테스트케이스 설계, 진행, 결과 확인 등을 지원하는 테스트 프레임워크
	ㄹ. NTAF
	: FitNesse의 협업 기능과 STAF의 재사용 및 확장성을 통합한 NHN의 프레임워크
	ㅁ. Selenium
	: 다양한 브라우저 및 개발 언어 지원하는 웹 어플리케이션 테스트 프레임워크
	ㅂ. watir
	: Ruby를 사용하는 애플리케이션 테스트 프레임워크
	*Ruby
	: 마츠모토 유키히로가 개발한 객체 지향 스크립트 언어

인터페이스 구현 감시 도구
	- APM(Application Performance Management)을 사용하여 감시 가능
	*APM
	: 애플리케이션 성능 관리 서비스
	- 애플리케이션 성능 관리 도구를 통해 데이터베이스와 웹 애플리케이션의
	  다양한 정보를 조회하고 분석할 수 있음
	- 스카우터(Scouter), 제니퍼(Jennifer) 등

인터페이스 구현 검증 도구 및 감시 도구 선택
	- 인터페이스 명세서의 세부 기능을 참조하여 검증 도구와 감시 도구의 요건을 분석
	- 분석 후 시장 및 솔루션 조사를 통해 적절한 도구 선택

인터페이스 구현 검증 확인
	- 외부 시스템과 연계 모듈 동작 상태 확인
	- 예상되는 결과값과 실제 검증 값이 동일한지 비교

인터페이스 구현 감시 확인
	- 외부 시스템과 연결 모듈이 서비스를 제공하는 동안 정상적으로 동작하는지 확인































